<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>diary-20221119</title>
      <link href="/2022/11/19/20221119/"/>
      <url>/2022/11/19/20221119/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，这个密码看着不太对，请再试试。" data-whm="抱歉，这个文章不能被纠正，不过您还是能看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="6ffda16fab2c3e4c4d3b02b2f6b8cbdfa18d4d30a86a27a9666c0163483454bf">1b976670f28fce93497a5e34b31c94ab9dbb8517960c3c72b84b3ecb54006e7da216b6ef36d09404eca5fe904106c854e6e44cf06602fb1c3916c6a705a4f4264f79733c71312c536ef10b87fe94dfaae0d7e63c5beba19e04df6614f80f6d375d4f9e84e98c3c497fcd52ede15aa738e236ef3fcc1771716d7e341ac392ff34d2ace895204820ad2916eb993622871a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好，这里需要密码。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> 加密文章tag </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类的特殊成员</title>
      <link href="/2022/10/11/%E7%B1%BB%E7%9A%84%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98/"/>
      <url>/2022/10/11/%E7%B1%BB%E7%9A%84%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98/</url>
      
        <content type="html"><![CDATA[<h1 id="类的特殊成员"><a href="#类的特殊成员" class="headerlink" title="类的特殊成员"></a>类的特殊成员</h1><p>1.静态成员</p><p>2.友元</p><p>3.常量成员</p><h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p>静态成员在类中分为静态数据成员和静态函数成员</p><h3 id="静态数据成员"><a href="#静态数据成员" class="headerlink" title="静态数据成员"></a>静态数据成员</h3><p>静态数据成员的创建方式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意初始化格式</span></span><br><span class="line"><span class="type">int</span> A::a=<span class="number">5</span>;<span class="comment">//只能通过类外初始化或者类内公有函数初始化。</span></span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>①静态数据成员作用于类内，存储在内存的静态全局区上，所以它的生命周期的开始早于主函数。</p><p>②静态数据成员无法在定义时初始化，只能通过<strong>类外初始化</strong>或者<strong>类内公有函数初始化</strong>。（有资料说能在类内重新赋值，我不理解）</p><p>③静态数据成员属于类，不属于对象，但是可以公有属性的静态数据成员可以被对象在类外访问。</p><p>④静态数据成员生命开始早于对象，当然可以被类内其他成员函数使用。（得符合访问属性）</p><h3 id="静态函数成员"><a href="#静态函数成员" class="headerlink" title="静态函数成员"></a>静态函数成员</h3><p>静态数据成员的创建方式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> a;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::func</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//只能使用静态数据成员、局部变量、形参等等，不能使用类内其他数据成员或成员函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>①静态函数成员的作用域和生命周期与静态数据成员一致。</p><p>②静态函数成员可以在类内定义，也可以在类外定义。</p><p>③静态函数成员就<strong>相当于普通函数</strong>，只不过能够使用静态数据成员罢了。</p><p>④静态函数成员生命开始早于对象，当然可以被类内其他成员函数使用。（得符合访问属性）</p><h3 id="软件设计模式——单例模式"><a href="#软件设计模式——单例模式" class="headerlink" title="软件设计模式——单例模式"></a>软件设计模式——单例模式</h3><p>单例模式，顾名思义就是<strong>只能实例化一个对象</strong>的模式</p><p>方法：</p><p>①私有化（private）<strong>构造函数与拷贝构造</strong>，防止类外创建对象的可能。</p><p>②在类内私有访问区域创建一个静态对象（为什么是静态？因为只有静态对象才可以在类内被创建啊），可以通过指针，也可以直接实例化（这样的话后续使用要通过引用）。</p><p>③提供一个静态的公有函数区获取这个私有对象。并且因为是静态对象，内存的静态存储区，生命周期贯穿整个程序，以后每次调用的就都会是这个对象，实现单例。</p><p>下面是一个例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">Box</span>()&#123;&#125;;</span><br><span class="line"><span class="built_in">Box</span>(<span class="type">const</span> Box&amp; box)&#123;&#125;;</span><br><span class="line"><span class="type">static</span> Box* p_box;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> Box* <span class="title">get_box_ptr</span><span class="params">()</span></span>;<span class="comment">//类内定义会被内联吗？</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;ok&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;；</span><br><span class="line">Box* Box::p_box=<span class="keyword">new</span> Box;</span><br><span class="line"><span class="function">Box* <span class="title">Box::get_box_ptr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> p_box;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Box* p=Box::<span class="built_in">get_box_ptr</span>();<span class="comment">//使用p指针获取对象</span></span><br><span class="line">p-&gt;<span class="built_in">speak</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>友元分为友元函数和友元类，友元的作用就是<strong>打破类的封装</strong>。</p><h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>友元函数就是一个普通函数，可以访问其已经声明为友元的类中的所以成员，包括静态（构造&#x2F;析构等不行）</p><p><strong>声明方法：</strong>（声明的位置<strong>没有限制</strong>，<strong>在类的花括号内就可以</strong>）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">func</span><span class="params">(A&amp; a)</span></span>;<span class="comment">//要传对象进去，不然无法操作，引用与否自己决定。</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>友元函数要想同时无限制的访问更多类，就得增加函数参数，并且在那些类中声明友元。</p><h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><p>友元函数就是一个普通类，可以访问其已经声明为友元的类中的所以成员，包括静态（构造&#x2F;析构等不行）</p><p>声明方法与友元函数一致。</p><p><font color=red><strong>注意：</strong></font></p><p>友元的特性：①单方向</p><p>​②不传递</p><p>​③不继承</p><h2 id="常量成员"><a href="#常量成员" class="headerlink" title="常量成员"></a>常量成员</h2><p>类的常量成员包括：常量数据成员、常量函数成员、常量对象。</p><h4 id="常量数据成员"><a href="#常量数据成员" class="headerlink" title="常量数据成员"></a>常量数据成员</h4><p>在数据成员前加const限定符，常量数据成员不能被修改，且初始化有要求，只能用<strong>成员初始化列表</strong>的方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a;</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> val):<span class="built_in">a</span>(val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常量函数成员"><a href="#常量函数成员" class="headerlink" title="常量函数成员"></a>常量函数成员</h4><p>常量函数成员<strong>声明方法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getnum</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量函数成员就是一个<strong>不能改变所在对象数据</strong>的<strong>成员函数</strong>。这是因为语法限制this指针不能使用，别的都可以。</p><h4 id="常量对象："><a href="#常量对象：" class="headerlink" title="常量对象："></a><strong>常量对象：</strong></h4><p><strong>常量对象不</strong>能通过接口改变对象内的数据**。</p><p>所以编译器不允许常量对象调用普通成员函数，只能调用常量成员函数。</p><p><font color=red>常量对象内的数据可以被友元改变吗？</font></p><p><strong>答</strong>：不能，因为友元函数需要传入对象作为参数，所以常量对象传入时，友元的参数类型必须与之相匹配，也就是const student（以student为例子），那么自然就不能更改，因为是const类型的对象。</p>]]></content>
      
      
      <categories>
          
          <category> c++学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>拷贝构造函数</title>
      <link href="/2022/10/11/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
      <url>/2022/10/11/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>拷贝构造是特殊的构造类型，也会影响类内是否会创建默认构造函数。</p><p>单纯<strong>只有拷贝构造也可以创建对象</strong>。</p><p>静态数据成员无法在类内初始化，只能在类外（main函数内也不行，得在静态全局区），但可以通过相应对象的接口进行赋值。</p><p>拷贝构造是一种通过自身类型来构造自身的构造函数，用户可以自定义拷贝构造，系统会默认给出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:<span class="type">int</span> a=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">student stu1;</span><br><span class="line">student stu2=stu1;</span><br></pre></td></tr></table></figure><p>这里系统给出了一个默认拷贝构造，把stud1的数据成员一个一个地赋值给stu2;</p><h3 id="创建方法："><a href="#创建方法：" class="headerlink" title="创建方法："></a>创建方法：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:<span class="type">int</span> a=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">student</span>(<span class="type">const</span> student&amp; stu)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a=stu.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：①函数名与类名一致</p><p>​②参数必须是本类型的一个引用变量</p><p>​③因为只是复制，加上const保险一些</p><p>​</p><h3 id="调用时机"><a href="#调用时机" class="headerlink" title="调用时机"></a>调用时机</h3><p>一、用同类型对象<strong>初始化对象时</strong>（只是在<strong>定义新对象</strong>时可以）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">student stu1;</span><br><span class="line">student stu2=stu1;<span class="comment">//这个方式也是适用与自定义拷贝构造的</span></span><br></pre></td></tr></table></figure><p>二、类为函数形参类型时</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(student a)</span></span>&#123;&#125;;</span><br></pre></td></tr></table></figure><p>对象作为形参传入时，实际上传入的是student类型对象的一个副本，自然调用了拷贝构造。</p><p>三、类为函数返回值类型时</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">student <span class="title">test</span><span class="params">(student a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对象返回时实际上返回的时对象a的一个副本，事实上这里调用了两次拷贝构造，使用返回的是初始传入对象的副本的副本。</p><h3 id="注意问题：浅拷贝与深拷贝"><a href="#注意问题：浅拷贝与深拷贝" class="headerlink" title="注意问题：浅拷贝与深拷贝"></a>注意问题：浅拷贝与深拷贝</h3><p><strong>浅拷贝</strong>：</p><p>我们在使用系统默认拷贝函数时，对象内数据成员是一个一个“&#x3D;”过去的。这种拷贝正常情况不会出现问题，但是一旦涉及指针，就会出现问题。<strong>指针与指针相等实际上仍然指向的是同一段内存</strong>，原来对象的内容并没有复制过去，甚至在原对象释放之后，新对象中的指针还会变成<strong>野指针</strong>。</p><p><strong>深拷贝</strong>：</p><p>我们一般使用浅拷贝就够了，一旦涉及指针，那就需要动态申请内存，所以需要自定义拷贝函数，使用<strong>深拷贝</strong>。</p><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">char</span>* name;</span><br><span class="line"><span class="built_in">student</span>(<span class="type">char</span>* name)<span class="comment">//构造函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;name=<span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(name)+<span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name,name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">student</span>(<span class="type">const</span> student&amp; stu)&#123;<span class="comment">//拷贝构造</span></span><br><span class="line">       <span class="keyword">this</span>-&gt;name=<span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(stu.name)+<span class="number">1</span>];<span class="comment">//动态分配内存</span></span><br><span class="line">       <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name,stu.name);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>问题：拷贝构造可以有多个吗？</strong></p><p><strong>不能，这个和析构函数是一个道理的，因为拷贝构造函数析构都是系统自动调用的，不能让系统陷入为难的选择之中。，不能重载。</strong></p>]]></content>
      
      
      <categories>
          
          <category> C++学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++第四次学习</title>
      <link href="/2022/10/10/C++%E7%AC%AC%E5%9B%9B%E6%AC%A1%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/10/10/C++%E7%AC%AC%E5%9B%9B%E6%AC%A1%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="对象的相关知识"><a href="#对象的相关知识" class="headerlink" title="对象的相关知识"></a>对象的相关知识</h1><p>1.面向对象</p><p>2.类与对象</p><p>3.对象的生命周期</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>面向对象的方法就是将数据与行为结合在一起，共同表达一个对象，通过对象解决问题。</p><p><strong>面向对象的特点：</strong>①封装性：对象内数据私有化，提供公有属性的接口以访问数据</p><p>②继承：对象可以派生出一个新的对象，有限制的继承原有对象的数据和接口。</p><p>③多态：面向对象的核心，实现同一个接口，不同的实例可以实现不同的操作。</p><p><strong>优点：高内聚，低耦合</strong></p><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>我们都使用过基本数据类型，类就是自定义的数据类型。与C语言的结构体不同，在C++中，这些新的数据类型不仅可以存数据，还可以内置接口，存在访问控制。</p><p><strong>类的定义：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>;<span class="comment">//事先声明可要可不要</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;;</span><br><span class="line">&#125;;<span class="comment">//定义，要加分号</span></span><br></pre></td></tr></table></figure><p><strong>类的访问控制：</strong></p><p>public：类内类外都可以访问</p><p>protected：类内和派生类可以访问</p><p>private：只有类内可以访问</p><p><strong>this指针：</strong></p><p>this指针作用在类内，始终指向实例化的对象。</p><p>与-&gt;运算符连用</p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>对象就是实例化的类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line">a.<span class="built_in">add</span>();<span class="comment">//调用接口</span></span><br><span class="line">a.a=<span class="number">0</span>;<span class="comment">//调用数据成员</span></span><br></pre></td></tr></table></figure><h2 id="对象的生命周期"><a href="#对象的生命周期" class="headerlink" title="对象的生命周期"></a>对象的生命周期</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数在对象创建时调用，用以初始化对象，<strong>没有构造函数创建不了对象。</strong></p><p>构造函数不完成初始化任务不会报错，但是构造函数体 不能为空。未完成初始化任务时，允不允许调用未初始化变量得看情况，后面有<strong>讨论</strong>。</p><font color=red>**补充：**</font><p><strong>没有构造函数创建不了对象。</strong>这句话有失偏颇，这里是一些经验，后面再来总结：</p><p>的确，在使用自定义的构造函数时，函数体如果为空，编译器就会报错，不允许我们运行程序，自然创建不了对象。</p><p>但是，在使用系统默认无参的时候，是可以运行的，并且能够创建对象，下面是细分的几种情形：</p><p>下面各个例子对应这个类：</p><p><strong>讨论</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>①</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br></pre></td></tr></table></figure><p>使用这种方式可以创建对象，也可以在类外对公有属性的数据成员赋值，但是不能调用未初始化的成员，会报错。</p><p>②</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">A <span class="title">a</span><span class="params">()</span></span>;<span class="comment">//无意义</span></span><br></pre></td></tr></table></figure><p>③</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A* p=new A;</span><br></pre></td></tr></table></figure><p>使用这种方式可以创建对象，甚至可以通过“p-&gt;”的方式访问未初始化的数据成员！</p><p>④</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A* p=<span class="keyword">new</span> <span class="built_in">A</span>();</span><br></pre></td></tr></table></figure><p>这种方式更离谱，直接会初始化int,float,double型的数据成员为0，char类型初始化为空格(控制台显示一个为空白字符)</p><p><strong>定义</strong></p><p>1.构造函数名与类名相同</p><p>2.构造函数没有返回值和返回值类型</p><p>3.构造函数可以重载，满足重载条件</p><p><strong>构造函数的创建：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">A()&#123;</span><br><span class="line">this-&gt;a=1;</span><br><span class="line">&#125;;</span><br><span class="line">int a=0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>类必须要有构造函数，而且可以有多个</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里看似没有构造函数，实际上存在一个编译器默认的无参构造，<strong>在程序员没有给出构造函数时自动产生</strong>。</p><p>一旦给出自定义构造函数，编译器便不会参数默认构造，程序员自定义的构造函数得完成初始化任务，不然会报错。</p><p>下面是一些错误例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里构造函数存在，但是在私有访问控制内，无法被调用，初始化失败，对象无法被创建</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;a=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里构造函数存在，但是构造函数函数体为空，无法完成初始化任务，同样无法创建</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不管是选择编译器的默认构造，还是自定义的无参或有参构造。我们创建对象的方式要与我们选择的构造函数对应。</p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">123</span>)</span></span>;</span><br><span class="line">A a;</span><br><span class="line">A* p=<span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">123</span>);</span><br><span class="line">A* p=<span class="keyword">new</span> A;</span><br></pre></td></tr></table></figure><p>以上伪代码展示了创建对象的不同方式，要与构造函数对应。</p><h4 id="成员初始化列表"><a href="#成员初始化列表" class="headerlink" title="成员初始化列表"></a>成员初始化列表</h4><p>当我们使用自定义构造函数但是又不想构造函数体内完成时，我们可以使用成员初始化列表的方式<strong>改造构造函数</strong>来完成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> val);</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line">string str;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line">A::<span class="built_in">A</span>(<span class="type">int</span> val):<span class="built_in">a</span>(val),<span class="built_in">ch</span>(<span class="string">&#x27;s&#x27;</span>),<span class="built_in">str</span>(<span class="string">&quot;hello&quot;</span>)<span class="comment">//这里的val是常量，传入</span></span><br><span class="line">&#123;&#125;;</span><br></pre></td></tr></table></figure><p>如上，通过运算符  ‘ : ‘  连接成员初始化列表，各成员之间用逗号隔开。</p><p><strong>注意：</strong></p><p>①从概念上说，这些初始化工作早与构造函数括号内的代码</p><p>②这种方法只限于构造函数</p><p>③<font color=red><strong>非静态const数据成员只能用这种方法初始化。</strong></font>正常的构造函数必然在构造函数体内通过this指针来初始化，但是这不可能成功，正常的赋值操作必须是可修改的左值。</p><p>④<font color=red><strong>必须用这种格式来初始化引用数据成员</strong></font></p><p>⑤成员列表必须<strong>包含全部数据成员</strong>，不能遗漏。</p><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>对象在死亡时可能需要一些清理操作，所以析构函数产生了。对象死亡时，会自动调用析构函数。</p><p>析构函数只能有一个，析构函数是在对象死亡时自动调用，<strong>但也可以主动调用析构</strong>（前提是在类外调用得到）。</p><p>注意点：</p><p>①析构函数名与类名一致，在前面加一个~</p><p>②析构函数没有返回值类型和返回值，，也没有参数。</p><p>③如果用户不自定义析构函数，系统会给出一个啥也不干的析构函数。</p><p>问题：<strong>主动调用析构不会释放对象？</strong></p>]]></content>
      
      
      <categories>
          
          <category> C++学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++  第三次学习</title>
      <link href="/2022/10/10/C++-%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/10/10/C++-%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="C-第三次学习"><a href="#C-第三次学习" class="headerlink" title="C++  第三次学习"></a>C++  第三次学习</h1><p>1.new和delete动态分配内存</p><p>2.命名空间</p><p>3.cin和cout</p><p>4.string类的基本运用</p><h2 id="动态分配内存"><a href="#动态分配内存" class="headerlink" title="动态分配内存"></a>动态分配内存</h2><p>之前c语言时，动态分配内存是通过malloc()和free()等等函数完成的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//void *malloc(size_t size);</span></span><br><span class="line"><span class="type">int</span>* p=(<span class="type">int</span>* )<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*num);<span class="comment">//malloc()括号内为字节数。</span></span><br><span class="line"><span class="comment">//relloc()是重新分配内存，这里存在判定，如果原来的空间够用（后面的使用），则不会分配，函数返回原来内存的指针；如果不够用，则会执行重新分配，并将原来数据复制过去，返回新内存的首地址。</span></span><br></pre></td></tr></table></figure><h3 id="new的基本用法："><a href="#new的基本用法：" class="headerlink" title="new的基本用法："></a>new的基本用法：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type* var_name=<span class="keyword">new</span> type;</span><br><span class="line">type* var_name=<span class="keyword">new</span> <span class="built_in">type</span>(<span class="number">1</span>);<span class="comment">//分配一个并初始化。在类的相关内容中，这里还意味着调用构造函数进行初始化。</span></span><br><span class="line">type* var_name=<span class="keyword">new</span> type[<span class="number">5</span>];<span class="comment">//连续分配，注意要使用memset()函数初始化</span></span><br></pre></td></tr></table></figure><h3 id="memset-函数初始化："><a href="#memset-函数初始化：" class="headerlink" title="memset()函数初始化："></a>memset()函数初始化：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">memset</span>(p,<span class="number">0</span>,<span class="number">20</span>);<span class="comment">//对首地址开始的20个字节置0；</span></span><br></pre></td></tr></table></figure><h3 id="delete的基本用法："><a href="#delete的基本用法：" class="headerlink" title="delete的基本用法："></a>delete的基本用法：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">delete</span> []p;<span class="comment">//连续</span></span><br><span class="line"></span><br><span class="line">p=<span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>注意：不要出现解引用未初始化指针的情况。</p><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p><strong>命名空间</strong>是一种组织和重用代码的编译单元，可以有效避免多人协作开发时的命名冲突问题。</p><h3 id="命名空间定义方式-命名空间不存在声明一说"><a href="#命名空间定义方式-命名空间不存在声明一说" class="headerlink" title="命名空间定义方式(命名空间不存在声明一说)"></a><strong>命名空间定义方式</strong>(命名空间<strong>不存在声明</strong>一说)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> space_name&#123;</span><br><span class="line"></span><br><span class="line">&#125;;<span class="comment">//这个花括号是作用域</span></span><br></pre></td></tr></table></figure><p>注意：花括号在C++中有两种形态：①作用域②定义域</p><p>其中定义域必须加分号，作用域没有强制要求。</p><p><strong>函数的花括号也是作用域。</strong></p><p> 命名空间可以嵌套。</p><h3 id="命名空间取别名："><a href="#命名空间取别名：" class="headerlink" title="命名空间取别名："></a>命名空间取别名：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> AA&#123;&#125;;</span><br><span class="line"><span class="keyword">namespace</span> VV=AA;<span class="comment">//此时VV就是AA</span></span><br></pre></td></tr></table></figure><h3 id="命名空间的使用"><a href="#命名空间的使用" class="headerlink" title="命名空间的使用"></a>命名空间的使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> A::a;<span class="comment">//开放单一的名称</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> A;<span class="comment">//全部命名空间都开放</span></span><br></pre></td></tr></table></figure><p>C++11 有了新添加：内联命名空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">inline namespace AA&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">namespcae AA&#123;</span><br><span class="line"></span><br><span class="line">&#125;;//由于命名空间会自动合并，所以这个也是内联的</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="cin和cout"><a href="#cin和cout" class="headerlink" title="cin和cout"></a>cin和cout</h2><p>iostream头文件的库函数，对标c语言的printf()、scanf();</p><p>简单使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x,y,z=<span class="number">1</span>;</span><br><span class="line">cout&lt;&lt;x&lt;&lt;y&lt;&lt;z;<span class="comment">//输出</span></span><br><span class="line">cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;<span class="comment">//依次输入，记得间隔空格</span></span><br><span class="line"><span class="comment">//注意：对于转义字符等要用双引号</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p>之后继续深入，实际上cin和cout都是对象，所以都有相应的接口。</p><h2 id="string类的基本用法"><a href="#string类的基本用法" class="headerlink" title="string类的基本用法"></a>string类的基本用法</h2><p>用于存储字符串：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string str=<span class="string">&quot;hello world&quot;</span>;<span class="comment">//hello world\0;</span></span><br></pre></td></tr></table></figure><p>该对象str的一些接口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str.<span class="built_in">length</span>();<span class="comment">//计算长度</span></span><br><span class="line">str.<span class="built_in">empty</span>();<span class="comment">//返回bool值，空则1.非空则0；</span></span><br><span class="line">str.<span class="built_in">clear</span>();<span class="comment">//清空字符串</span></span><br><span class="line">str.<span class="built_in">at</span>(<span class="number">3</span>);<span class="comment">//或得字符串化成字符数组后下标为3的字符</span></span><br><span class="line">str.<span class="built_in">assign</span>(str2);<span class="comment">//返回对象str自身的引用，这里括号内也可以是&quot;das&quot;.&#x27;a&#x27;;</span></span><br><span class="line">str.<span class="built_in">swap</span>(str2);<span class="comment">//与str2交换内容</span></span><br><span class="line">str.<span class="built_in">substr</span>(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//返回一个str的子串，从str下标为1的位置开始，截取2个字符的长度。</span></span><br></pre></td></tr></table></figure><h2 id="一些补充"><a href="#一些补充" class="headerlink" title="一些补充"></a>一些补充</h2><p>①三目运算符 x&gt;y?x:y</p><p>在C++中返回的是变量，而不是c语言中的常量</p><p>②C++中必须写返回值类型</p><p>③C++不允许出现如下二义性操作，而c语言可以：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> a=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>④在c++中const类型可以作为常量使用，比如数组大小，而c语言不可以</p><p>⑤不要返回局部或者临时变量的地址（它们在函数执行完后都会被释放内存，返回的是随机的地址）</p>]]></content>
      
      
      <categories>
          
          <category> C++学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 第二次学习 bool...</title>
      <link href="/2022/10/09/C++-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AD%A6%E4%B9%A0-bool/"/>
      <url>/2022/10/09/C++-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AD%A6%E4%B9%A0-bool/</url>
      
        <content type="html"><![CDATA[<h1 id="C-第二次学习"><a href="#C-第二次学习" class="headerlink" title="C++ 第二次学习"></a>C++ 第二次学习</h1><p>1.Bool类型</p><p>2.内联函数</p><p>3.引用</p><p>4.函数重载与参数缺省</p><h2 id="Bool类型"><a href="#Bool类型" class="headerlink" title="Bool类型"></a>Bool类型</h2><p>1.独属于c++的逻辑类型</p><p>2.取值为true或false，但在控制台输出为1&#x2F;0</p><p>3.定义方式 （与基本类型类似）Bool istrue &#x3D;1；</p><p> 4.内存大小占用1字节</p><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>​        内联函数是程序员对编译器提出的一个建议，建议编译器在编译程序代码的时候，把该函数的代码 内嵌到程序代码中具体调用该函数的位置，将这个函数放在代码区，调用时不再进出栈区，由此提高程序执行效率，节省栈区空间。但是具体是否内联成功，还是要由编译器决定。</p><p>​内联函数的关键字为 <strong>inline</strong> ,将关键字放在所要内联的函数的定义之前，注意，是定义，放在声明前是没意义的。</p><p>​不是所有函数都适合内联的，一般我们将要重复调用并且函数代码简单（一般不超过10行）（简单运算或者赋值）设置为内联函数。此外，还有一些补充点：<br>​①内联函数中不建议使用循环或者开关语句，这样有违内联函数初衷，会导致代码膨胀，有些编译器会报错，有些不会。</p><p>​②在类内定义的成员函数都是内联函数。</p><p>​③递归函数、虚函数等不会被正常内联</p><p>内联函数的应用</p><p>一：定义类成员变量的存取函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span>&#123;</span><br><span class="line">　<span class="keyword">private</span>:</span><br><span class="line">　　<span class="type">int</span> a;</span><br><span class="line">　<span class="keyword">public</span>:</span><br><span class="line">　　<span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> a;&#125;   <span class="comment">//读取成员变量</span></span><br><span class="line">　  <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> I)</span> </span>&#123;a=I;&#125;    <span class="comment">//设置成员变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二：实现宏的效果</p><p>宏在使用时，不进行参数检查，容易出现二义性。比如实现计算x平方：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TABLE_MULTI(x) ((x)*(x));</span></span><br></pre></td></tr></table></figure><p>若输入参数为表达式：a++; (a&#x3D;4),</p><p>​他们本意是希望得到(a+1)* (a+1)的结果，而实际上呢？我们可以看看宏的展开结果: (a++) * (a++)，如果a的值是４，我们得到的结果是5*6&#x3D;30,而我们想要的是25。</p><p>改为内敛函数则无此歧义，因为内敛函数是<strong>真正的函数</strong>，执行的是函数的调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; <span class="keyword">return</span> x*x;&#125;;</span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>取引用的符号是&amp; ，这与变量的取址符不一样。取引用就是一个取别名的过程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>&amp; b=a;<span class="comment">//注意：定义的适合一定要初始化，否则报错！！！</span></span><br></pre></td></tr></table></figure><p>如上述，定义了一个a的引用，结果：</p><p>①b就是a，b可以当作a使用；</p><p>②取引用就<strong>不能修改</strong>引用的对象；</p><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>函数重载的条件是函数名一致，参数列表不一致，所谓的参数列表不一致，就是：</p><h4 id="参数列表的参数个数、参数类型、参数顺序不一致（满足一个即可）；"><a href="#参数列表的参数个数、参数类型、参数顺序不一致（满足一个即可）；" class="headerlink" title="参数列表的参数个数、参数类型、参数顺序不一致（满足一个即可）；"></a><strong>参数列表的参数个数、参数类型、参数顺序不一致（满足一个即可）；</strong></h4><p>函数重载要避免产生的<strong>二义性</strong>：（当参数不匹配时，编译器的隐式转换作祟）</p><p>看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有两个函数add，构成重载</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">add</span><span class="params">(<span class="type">float</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line"><span class="comment">//调用函数add</span></span><br><span class="line"><span class="built_in">add</span>(<span class="number">2.5</span>);</span><br></pre></td></tr></table></figure><p>此时，2.5实际上为double类型，找不到匹配的参数，编译器会强转这个double类型参数，可以转为int，也可以转为float，编译器不知道怎么做，会报错。</p><p>解决方式：①再写一个匹配的函数；</p><p>​                   ②改变传入的参数，可以使用显式转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add</span>((<span class="type">int</span>)<span class="number">2.5</span>)</span><br></pre></td></tr></table></figure><h2 id="参数缺省"><a href="#参数缺省" class="headerlink" title="参数缺省"></a>参数缺省</h2><p>函数参数缺省本质就是设置默认值，要求从右到左缺省。缺省的设置在函数的定义或声明其中一个中完成就可以。</p><h4 id="注意：缺省值只能是常量"><a href="#注意：缺省值只能是常量" class="headerlink" title="注意：缺省值只能是常量"></a><strong>注意：缺省值只能是常量</strong></h4><p>函数缺省要避免与函数重载产生二义性：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有两个函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getnum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c=<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getnum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="built_in">getnum</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><strong>此时编译器不知道是调用两个函数中的哪一个，会报错</strong></p><p>解决办法：没有，只能取消缺省或者取消重载。</p>]]></content>
      
      
      <categories>
          
          <category> C++学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>混淆点：栈、堆</title>
      <link href="/2022/10/08/%E6%B7%B7%E6%B7%86%E7%82%B9%EF%BC%9A%E6%A0%88%E3%80%81%E5%A0%86%E3%80%81%E7%BC%93%E5%AD%98%E3%80%81%E7%BC%93%E5%86%B2%E5%8C%BA%E3%80%81%E5%86%85%E5%AD%98%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%BB%AC%E4%B8%8E%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
      <url>/2022/10/08/%E6%B7%B7%E6%B7%86%E7%82%B9%EF%BC%9A%E6%A0%88%E3%80%81%E5%A0%86%E3%80%81%E7%BC%93%E5%AD%98%E3%80%81%E7%BC%93%E5%86%B2%E5%8C%BA%E3%80%81%E5%86%85%E5%AD%98%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%BB%AC%E4%B8%8E%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<p>首先，程序都是在内存中运行的，故而堆栈都处在内存里。</p><p><strong>内存中包括</strong>：栈区、堆区、静态、静态存储区、文字常量区、程序代码区五个</p><p>其中：</p><p>!()[“C:\Users\14742\Desktop\blog\public\img\内存五区.png”]</p><p>1.栈区：执行函数的时候，函数内部（包括main函数）的局部变量都在栈区创建，程序结束时由程序自动释放。</p><p>这种栈内存分配的相关运算是由cpu的寄存器来存取的，效率高，但分配空间有限（<strong>但不是分配在寄存器上，别混淆，寄存器只是一个媒介</strong>），只有几MB，可以通过编译器选项修改。</p><p>2.堆区：</p><p>堆区就由程序员手动分配的存储区，使用malloc(),new等函数分配，free delete等函数释放，优点是灵活，代价是容易被程序员遗忘释放操作。未释放的内存在程序结束时由系统收回。</p><p>3.静态区&#x2F;<strong>全局区</strong>&#x2F;全局静态区&#x2F;静态全局区：</p><p>细分为：data区，bbs区，常量区</p><p>　　　　①全局变量和静态变量是<strong>放在一起的</strong>。</p><p>　　　　②初始化的全局变量和静态变量放在一个区：<strong>data</strong> segment</p><p>　　　　③未初始化 的放在相邻的另一个区: <strong>bss</strong>(block started by symbol)。 该区在编译好的目标文件中不被分配内存，只是记录所需要的大小。</p><p>　　　　<strong>为什么要将初始化和未初始化的变量分别存放在两个区：</strong></p><p>　　　　　　a. 内存是否被分配的区别</p><p>　　　　　　b. 未初始化的放在bss区，在程序启动时可以统一调用memset，将为初始化的统一初始化为0或NULL。（注意：只是全局区未初始化对象会调用，<strong>栈区的不会，栈区对象未初始化会直接报错</strong>）</p><p><strong>针对静态对象：</strong></p><p>由static声明变量，对应.c(cpp)文件，函数内部，class类的静态处理产生了三种静态对象：</p><p>①全局静态对象：对应.c(cpp)文件的静态</p><p>②局部静态对象</p><p>③class静态成员</p><p>对这三种对象处理：都是第一次运行时创建，程序结束时销毁</p><p>4.（文字）<strong>常量区</strong>：顾名思义就是存储文字常量的地方，存放常量(程序在运行的期间不能够被改变的量，例如: 10，字符串常量”abcde”， 数组的名字等)</p><p>问题：到底哪些常量是存放在常量区的呢，如果在函数内定义一个变量的时候，变量赋的值（比如 5这个数），这个5是放在栈区的内存上还是放在常量区</p><p>文字常量不可寻址（&amp;），除非转化为<strong>常变量</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; r=<span class="number">5</span>；</span><br></pre></td></tr></table></figure><p><strong>在数据区开辟一个值为5的无名整型常变量</strong></p><p>5.程序代码区：</p><p><strong>存放常量字符串，程序退出后由OS释放</strong></p><p>经典实例：（代码来自网络高手，没有找到原作者）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">＃include &lt;string&gt; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a=<span class="number">0</span>;  <span class="comment">//全局初始化区 </span></span><br><span class="line"><span class="type">char</span> *p1;  <span class="comment">//全局未初始化区 </span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="type">int</span> b;<span class="comment">//栈 </span></span><br><span class="line">  <span class="type">char</span> s[]=<span class="string">&quot;abc&quot;</span>;  <span class="comment">//栈 </span></span><br><span class="line">  <span class="type">char</span> *p2;     <span class="comment">//栈 </span></span><br><span class="line">  <span class="type">char</span> *p3=<span class="string">&quot;123456&quot;</span>;  <span class="comment">//123456\0在常量区，p3在栈上。 </span></span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> c=<span class="number">0</span>;  <span class="comment">//全局（静态）初始化区 </span></span><br><span class="line">  p1 = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>); </span><br><span class="line">  p2 = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">20</span>);  <span class="comment">//分配得来得10和20字节的区域就在堆区。 </span></span><br><span class="line">  <span class="built_in">strcpy</span>(p1,<span class="string">&quot;123456&quot;</span>);  <span class="comment">//123456\0放在常量区，编译器可能会将它与p3所向&quot;123456\0&quot;优化成一个地方。 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缓存、内存、缓冲区</p><p>①缓存包括<strong>程序缓存</strong>和<strong>cpu缓存</strong></p><p>②<strong>程序缓存就是缓冲</strong>区，包括内存的栈区和堆区</p><p>③CPU缓存：这是硬件层次缓存，处于内存条和CPU之间，以为比如CPU的L1 L2 L3等缓存机制，因为CPU缓存比CPU读内存数据更快！用于存放热点数据，数据如何分级存放有自己的算法。</p>]]></content>
      
      
      <categories>
          
          <category> C++学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vim及gcc</title>
      <link href="/2022/09/05/vim%E5%8F%8Agcc/"/>
      <url>/2022/09/05/vim%E5%8F%8Agcc/</url>
      
        <content type="html"><![CDATA[<p>n:next<br>std:standard:标准<br>h:head:头部<br>include:包含,包括<br>main:主要的,最重要的,入口<br>print:打印<br>format:格式<br>printf&#x3D;print format&#x3D;按照一定的格式进行打印输出<br>return:返回,结束<br>i:input:输入<br>o:output:输出</p><p>回顾：<br>1.计算机组成部分<br>   硬件<br>        三大件<br>    CPU<br>         数据运算和操作外设<br>    内存<br>        暂存数据,速度快,容量小<br>    硬盘<br>        永久性存储数据,速度慢,容量大<br>        外设<br>    可有可无<br>   软件<br>         操作系统<br>             驱动控制外设,分配CPU资源和内存资源等<br>         shell终端程序<br>             接收用户输入的命令并且执行命令<br>         应用程序<br>             QQ等</p><p>2.主流操作系统<br>   windows&#x2F;linux&#x2F;苹果&#x2F;安卓&#x2F;vxworks</p><p>3.linux系统的发展<br>   开源&#x2F;1991&#x2F;linus&#x2F;视频：the code linux&#x2F;<a href="http://www.kernel.org(官网)/">www.kernel.org(官网)</a></p><p>4.linux系统理念(信仰)：一切皆文件<br>   访问硬件必须先找到对应的文件<br>   访问文件就是在访问硬件本身</p><p>5.linux系统管理文件：文件系统<br>   不同文件系统管理文件方式不一样<br>    明确文件系统中相关概念：目录,文件,路径<br>    根目录’&#x2F;‘&#x2F;子目录&#x2F;父目录&#x2F;当前目录’.’&#x2F;上一级目录’..’&#x2F;主目录’~’<br>    文件：记录了一堆的数据信息<br>    路径：绝对路径（首选）和相对路径 </p><p>6.linux系统命令<br>   pwd&#x2F;clear&#x2F;ls&#x2F;cd&#x2F;mkdir&#x2F;touch&#x2F;rm&#x2F;cp&#x2F;mv&#x2F;echo(&gt;&#x2F;&gt;&gt;)&#x2F;<br>   grep&#x2F;cat&#x2F;find&#x2F;tar&#x2F;whoami(查看当前用户名)</p><p>详细：<br><strong>mv</strong>： 剪切、移动</p><p>mv  文件名(目录)  目标文件名（目标目录或目标目录下）   重命名……等等功能</p><p><strong>whoami</strong>：查看当前登录linux系统的用户名</p><p>直接写即可</p><p><strong>cat</strong>：快速查看文件内容 </p><p>格式：cat  文件路径</p><p><strong>输出结果</strong></p><p>对于目录：这是一个目录</p><p>对于文件：显示内容（比如txt文件，就把内容显示出来）</p><p><strong>echo</strong>：打印信息</p><p>格式：echo 打印信息</p><p>通常与&gt;&gt;或&gt;联用</p><p>例子：echo 我是人&gt;&#x2F;home&#x2F;ehe&#x2F;hello.txt   把“我是人”打印入hello.txt文件内，清除原有的内容</p><p>​echo 我是男生&gt;&gt;&#x2F;home&#x2F;ehe&#x2F;hello.txt  把“我是男生”打印入文件，在文件原有内容尾部先回车 ，再打印</p><p><strong>find</strong>：查找文件</p><p>格式：find 路径 -name 文件名             到指定路径下找一个名字叫“文件名”的文件</p><hr><p>7.掌握大名鼎鼎的linux编辑器软件：vim<br>7.1.常用的开发编辑器软件：vim,vscode,sublime等<br>      重点放在vim<br>7.2.vim命令格式：vim  文件名  &#x2F;&#x2F;打开一个文件<br>7.3.vim三种模式：可视模式,编辑模式,命令行模式<br>      可视模式：只能看不能编辑<br>      编辑模式：可以输入各种文本信息<br>      命令行模式：给vim输入各种控制命令<br>7.4.vim三种模式之间的转换：<br>       明确：第一次刚执行vim命令之后,首先进入可视模式<br>       可视模式—–按i键或者o键或者a键—-&gt;编辑模式<br>       编辑模式—–按ESC键—————–&gt;可视模式<br>       可视模式—–按shift+:组合键———&gt;命令行模式<br>       编辑模式—–先按ESC进入可视模式—&gt;按shift+:组合键———&gt;命令行模式<br>7.5.vim命令行模式下相关的命令<br>      w:保存文件<br>      q:不保存并且退出vim<br>      wq:先保存后退出vim<br>      q!:强制直接退出,不保存文件<br>      %s&#x2F;原来内容&#x2F;新内容&#x2F;g:将文件中原来的内容全部替换成新内容<br>      n1,n2s&#x2F;old&#x2F;new&#x2F;g:将文件从n1行到n2行所有的old内容换成new内容<br>          例如：6,9s&#x2F;小&#x2F;大&#x2F;g:将文件的第6行到第9行的小替换成大<br>      !  linux命令,例如：! ls :在vim命令中来执行linux的其他命令,再例如：! cd &#x2F;home&#x2F;tarena<br>      案例：练习vim,打开一个新文件,随意输入各种信息<br>7.6.vim快捷键(前提是先切换到可视模式下,然后再各种快捷键)<br>1)方向键以后不要用上下左右,而是用：h(左)j(下)k(上)l(右)替换<br>2)行选中：shift+v然后按hjkl方向键选中<br>    列选中：ctrl+v然后按hjkl方向键选中<br>3)复制：y键<br>4)粘贴：p键<br>5)剪切：x键<br>6)撤销：u键<br>7)撤销之后由反悔：ctrl+r<br>8)保存退出：ZZ键<br>9)先进入命令行模式执行:sp  文件名,实现上下分屏<br>   先进入命令行模式执行: vs  文件名,实现左右分屏<br>   目的：一个屏幕上可以同时编辑多个文件<br>   屏幕切换快捷键：ctrl+ww<br>10)搜索：先按&#x2F;然后再后面输入要搜索的信息,然后按小n键表示向下搜索,按大N键表示向上搜索<br>11)自动补全：ctrl+n,先输入开头的一个字符或者多个字符,然后按ctrl+n自动补全后面的内容<br>12)自动格式化文本内容,让代码变得整齐划一,好看：先行选中然后按&#x3D;键<br>13)跳转到文件的末尾：G键<br>14)跳转到文件的开头：gg键<br>15)跳转到指定的某个一行：先进入命令行模式,然后输入行号即可,例如：14,跳转到14行</p><h2 id="16-复制某几个单词-字母：先按v键-然后按方向键选中单词-字母-最后按y键复制或者按x剪切-然后按p键粘贴"><a href="#16-复制某几个单词-字母：先按v键-然后按方向键选中单词-字母-最后按y键复制或者按x剪切-然后按p键粘贴" class="headerlink" title="16)复制某几个单词,字母：先按v键,然后按方向键选中单词,字母,最后按y键复制或者按x剪切,然后按p键粘贴  "></a>16)复制某几个单词,字母：先按v键,然后按方向键选中单词,字母,最后按y键复制或者按x剪切,然后按p键粘贴  </h2><p>8.C语言<br>8.1.C语言定义：它是计算机编程的一种语言,除了C语言,还有C++,java,python等<br>            不管是哪种编程语言,他们都是实现人和计算机交流的<br>                           利用C语言能够编写一个程序,让计算机工作,例如：像显示器打印输出一段话<br>            例如：中国人&lt;—–汉语——-&gt;中国人<br>                      中国人&lt;—–汉语&#x2F;英语–&gt;美国人<br>                                      人&lt;———C语言&#x2F;C++语言等—-&gt;计算机</p><p>8.2.C语言发展<br>      C语言之父：丹尼斯里奇<br>      C语言经典书籍:&lt;<the c programming language>&gt;,作者丹尼斯里奇,正式推动了C语言发展<br>      1989,C89标准诞生<br>      1999,C99标准诞生,基于C89引入了一些优秀特性</p><p>8.3.人生的第一个C语言程序,C语言基本编程框架<br>具体实施步骤如下：<br>1)编写C程序<br>      cd &#x2F;home&#x2F;tarena<br>      mkdir stdc<br>      cd stdc<br>      vim  helloworld.c 添加输入以下内容：<br>      &#x2F;*<br>         这是我的第一个程序<br>         好开心啊<br>       *&#x2F;<br>       &#x2F;&#x2F;这是我的第一个程序<br>       &#x2F;&#x2F;好开心<br>      #include &lt;stdio.h&gt;<br>      int main(void)<br>      {<br>    printf(“hello,world\n”);<br>    return 0;<br>      }<br>     保存退出<br>程序说明(C语言编程规矩)：</p><ol><li>C程序的文件分两类：源文件和头文件,他两本质一样<br> 源文件都是以”.c”后缀结尾<br> 头文件都是以”.h”后缀结尾<br> 注意：任何C程序必须有一个源文件,可以不用自己写头文件</li><li>#include &lt;stdio.h&gt;：include在C语言中是一个关键字(有特殊含义功能的一个单词<br> 不可随意使用),如果include前面加#,表示要包含一个头文件<br> stdio.h:就是标准C语言的一个头文件(大神已经帮你写好了)<br> 此文件位于linux系统的&#x2F;usr&#x2F;include&#x2F;目录下<br> 问：这一对&lt;&gt;什么意思呢？<br> 答：如果是&lt;&gt;,表示将来让gcc编译器到&#x2F;usr&#x2F;include目录下找stdio.h头文件<br>    如果是”stdio.h”,表示将来gcc先到当前目录下找stdio.h,如果找不到再           去&#x2F;usr&#x2F;include目录下找<br> 结论：包含头文件的两种写法：<br> #include &lt;stdio.h&gt;<br> #include “stdio.h”<br>3.C程序只能有一个主函数叫main,并且main函数的前面必须是int<br>并且main函数后面要跟一对圆括号,括号里面写void<br>由于main函数是自己编写的,所以还要跟一对{},{}包含的内容就是main函数<br>将来给CPU运行的命令,也就是程序的执行必须从main函数开始<br>然后CPU从main函数依次一条条的向下执行<br>4.printf是一个函数,但是此函数是标准C语言已经写好的(大神写好的),咱们直接使用即可<br>为了使用此函数, 必须包含头文件：stdio.h<br>注意：’\n’表示换行<br>5.main函数中的每条语句必须跟分号来表示此条语句的结束<br>6.main函数最后执行return返回也就是让CPU执行到这程序就结束了<br>7.C程序的注释(代码的解释说明)两种方式：<br> 一对&#x2F;<em>注释的内容</em>&#x2F;：优点：多行注释,缺点：不能嵌套<br> 一对&#x2F;&#x2F;后面跟要注释的内容：优点：可以嵌套,缺点：只能单行注释</li></ol><p>2)编译C程序，执行以下命令：<br>    cd &#x2F;home&#x2F;tarena&#x2F;stdc&#x2F;<br>    gcc helloworld.c &#x2F;&#x2F;编译程序<br>    ls  -lh  &#x2F;&#x2F;查看a.out的详细信息,此a.out就是生成最终二进制可执行程序(计算机能够执行的一个文件)<br>       -rwx….    a.out<br>    .&#x2F;a.out  &#x2F;&#x2F;运行a.out这个程序,将来CPU根据程序的要求做相关的动作</p><p>程序编译说明：<br>1.gcc：它是一个编译器,类似翻译官,将源文件helloworld.c翻译成a.out计算机能够识别<br>            能够看懂的可执行文件<br>   gcc使用命令格式：gcc  源文件 (变态的编译方法),此种写法最终生产的文件都叫a.out<br>   问：如果不想取名叫a.out,怎么办呢？<br>   答：搞清楚gcc工作流程</p><p>8.4.gcc编译器特性<br>1)功能：将源文件翻译成可执行文件<br>2)gcc工作要经过三步骤(目前了解即可)：<br>   1.先预处理<br>      就是将别人的头文件内容全部拷贝到当期源文件中<br>      例如：#include &lt;stdio.h&gt;，意思就是将stdio.h里面的内容全部拷贝到helloworld.c中<br>   2.然后编译<br>      就是将预处理之后的源文件翻译成可执行文件(计算机对此文件是能够识别的)<br>   3.最后链接<br>      就是将别人写好的函数代码,例如printf,加载到自己编写的文件中,最终翻译成CPU<br>      能够执行运行的可执行文件<br>    问：以上三步骤如何分步骤实现呢？<br>    答：只需gcc的相关的选项即可完成<br>3)掌握gcc的常用选项：<br>  -o:  后面跟要生成的文件<br>  -E:进行预处理<br>       例如：gcc -E helloworld.c -o helloworld.i<br>                 语义：对helloworld.c进行预处理,生成预处理以后的文件helloworld.i<br>  -c:只编译不链接,只是把自己的源文件生成可执行文件,此过程不会将别的函数加载过来<br>       例如：gcc -c -o helloworld.o helloworld.i<br>    语义：将预处理文件helloworld.i只编译不链接生成可执行文件helloworld.o<br>                            helloworld.o此文件CPU识别,但是不能运行,因为还没有加载别人的函数</p><p>案例：演练gcc的三种使用方式<br>实施步骤如下：<br>cd &#x2F;home&#x2F;tarena&#x2F;stdc&#x2F;<br>ls  helloworld.c &#x2F;&#x2F;查看文件是否存在<br>第一种编译方式：流氓方法<br>gcc  helloworld.c  &#x2F;&#x2F;生成a.out<br>.&#x2F;a.out</p><p>第二种编译方式：分步骤编译<br>gcc -E -o helloworld.i helloworld.c &#x2F;&#x2F;先预处理<br>vim helloworld.i &#x2F;&#x2F;挑战看看此文件,只看文件的最后的内容(是自己编写的)<br>gcc -c -o helloworld.o helloworld.i &#x2F;&#x2F;然后只编译不链接<br>gcc -o helloworld  helloworld.o &#x2F;&#x2F;最后将helloworld.o进行链接操作生成最终的可执行文      件helloworld<br>.&#x2F;helloworld</p><p>第三种编译方式：一步到位<br>gcc -o helloworld helloworld.c<br>注意：此方法也就是将方法2进行合并了！</p><p>8.5.详解printf函数<br>1)此函数属于标准C的函数,直接使用即可<br>   但是需要包含头文件stdio.h<br>2)此函数的使用语法格式：<br>   printf(“输出的内容\n”);<br>   例如：<br>   printf(“hello,world\n”); &#x2F;&#x2F;输出hello,world信息之后再加一个换行<br>   printf(“hello,world”); &#x2F;&#x2F;只输出hello,world信息,但是没有换行<br>   printf(“%d, %d\n”, 1, 2); &#x2F;&#x2F;输出1,2<br>   说明：%d:占位符<br>             第一个%d给数字1占位，第二个%d给数字2占位</p><hr><p>9.详解内存特性和概念<br>1)内存功能：用于暂存程序和程序中的各种数据（cpu运算前后）(例如：1,2,3等)<br>   问：为何不用CPU和硬盘呢？<br>   答：CPU存的数太少了<br>          硬盘速度太慢了<br>          所以选择内存<br>          程序玩的不是程序,玩的是内存<br>2)内存相关的概念<br>   字节(俗称格子)：就是将内存划分为一块一块的区域,好比划分为一个一个格子一样<br>                每块区域简称字节,能够存储程序中的数据,也就是内存中最小的<br>                             存储单位就是字节<br>   地址:就是给内存的每个字节指定一个固定的唯一的编号,从0开始,类似给每个房间指定一个房间号一样<br>           此编号简称地址<br>   存储区：就是一个字节或者多个字节组成的存储区域,简称存储区<br>                 问：为何有这个概念呢？<br>    答：比如现在有一个数大小为300亿,明确告诉你一个字节肯定存不下300亿这个数<br>           所以需要4个字节的连续内存来存储300亿这个数,而这个4字节的内存区域构成了<br>                        存储区<br>   首地址：存储区的第一个字节的地址<br>                 内存条<br>                 *  *   *    *    ****   ….<br>                 0 1  2   3    4567 ….<br>         首地址：4                </p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> C语言初步 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>运算符继续</title>
      <link href="/2022/09/05/%E8%BF%90%E7%AE%97%E7%AC%A6%E7%BB%A7%E7%BB%AD/"/>
      <url>/2022/09/05/%E8%BF%90%E7%AE%97%E7%AC%A6%E7%BB%A7%E7%BB%AD/</url>
      
        <content type="html"><![CDATA[<p>复习：</p><p>逻辑运算符的短路算法</p><p>1.位运算</p><p>位与：：&amp;</p><p>位或：|</p><p>位异或：^</p><p>位反：~         <strong>注意前面的好多0也要取反</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~<span class="number">0x5a</span> （一个<span class="type">int</span>下）</span><br><span class="line">:<span class="number">0xffffffa5</span></span><br><span class="line">如果我不想看到那么多f怎么办呢</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> a=~<span class="number">0x5a</span>;<span class="comment">//将4字节的0xffffffa5保存到变量a中，其他的f全部丢失  这里由于明显除去f的是非负数，所以用unsigned char 就可以</span></span><br></pre></td></tr></table></figure><p>2.移位运算符</p><p>a&lt;&lt;b &#x2F;&#x2F;a左移b个位置，右边的空位用0补齐</p><p>a&gt;&gt;b &#x2F;&#x2F;a右移b个位置</p><p><strong>对于无符号类型数字：</strong></p><p>左边空出来的空位用0填充</p><p><strong>对于有符号类型的数字：</strong></p><p>左边空出来的空位<strong>用符号位（</strong>原来数的符号）填充</p><p>左移n位相当于乘以2的n次方，右移类推</p><p><strong>不要用乘除，效率低</strong> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">8</span>;</span><br><span class="line">a&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a);<span class="comment">//a的值是不改变的，只是拿着a的值的副本去左移右移</span></span><br></pre></td></tr></table></figure><p><strong>注意：原本的数可能会出现不能被整除的情况，所以右移后的数不严格等于除以2的n次方的数</strong></p><p>3.移位运算与位运算的结合</p><p><strong>a)位清0操作</strong></p><p><strong>原理</strong>：通过某些特定0位的二进制数如：11111110 （这种只有个别位为0的数）与原来数据进行按位与&amp;操作</p><p>（明确，按位&amp;运算中，真值不影响，假值影响才大）</p><p><strong>连续位清0，其他位保持不</strong></p><p><strong>公式：A &amp;&#x3D;~(B &lt;&lt; C )</strong></p><p><strong>说明：A:操作的数据</strong></p><p>​<strong>B:连续的位数  ：1&#x2F;3&#x2F;7&#x2F;0xf&#x2F;0x1f&#x2F;0x2f&#x2F;0x3f&#x2F;0xff</strong></p><p>​1位、2位、3位……</p><p>​        <strong>C:起始位</strong></p><p>1.将某个数据A的第0位清0，其他位保持不变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A &amp;=~(1&lt;&lt;0)</span><br></pre></td></tr></table></figure><p>2.将某个数据A的第1位清0，其他位保持不变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A&amp;=~(1&lt;&lt;1);</span><br></pre></td></tr></table></figure><p>3.将某个数据的第2位清0，其他位保持不变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A&amp;=~(1&lt;&lt;2);</span><br></pre></td></tr></table></figure><p>4.将某个数据的第0、1位清0，其他位保持不变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A&amp;=~(3&lt;&lt;0);</span><br></pre></td></tr></table></figure><p>5.将某个数据的的1、2位清0，其他位保持不变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A&amp;=~(3&lt;&lt;1);</span><br></pre></td></tr></table></figure><p>6.将某个数据的0、1、2、3位清0，其他位保持不变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A&amp;=~(0XF&lt;&lt;0); </span><br></pre></td></tr></table></figure><p><strong>b)位置1操作：</strong></p><p>原理：通过一个特定位为1的二进制数来与原数据进行按位|运算，实现置1；</p><p>（明确：在按位或运输中，假值不影响，真值才影响）</p><p><strong>连续位置1，其他位保持不变</strong></p><p><strong>公式：A  |&#x3D; (B&lt;&lt;C)</strong>     </p><p><strong>A:要特定位置1的数</strong></p><p><strong>B:连续的位数</strong></p><p><strong>C:连续位数的起始位</strong></p><p>1.将某个数据A的第0位置1，其他位保持不变</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A|=(<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>2.将某个数据A的第1位置1，其他位保持不变</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A|=(<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>3.将某个数据的第2位置1，其他位保持不变</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A|=(<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>4.将某个数据的第0、1位置1，其他位保持不变</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A|=(<span class="number">3</span>&lt;&lt;<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>5.将某个数据的的1、2位置1，其他位保持不变</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A|=(<span class="number">3</span>&lt;&lt;<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>6.将某个数据的0、1、2、3位置1，其他位保持不变</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A|=(<span class="number">0XF</span>&lt;&lt;<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>建议：如果将来操作的位数大于等于<strong>两位</strong>，建议清0后置1</p><p><strong>变换：</strong>以上是用于置0，置1 的，实际上，我们还可以进行一些进阶操作</p><p>如果我们要给一个二进制数的特定连续位设为某些特定值(这种方法要先把这些位清0）</p><p>例如：将数据0xe578a431的第4，5，6，7位置0xa，其他位保持不变</p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a =<span class="number">0xe578a431</span>;</span><br><span class="line"></span><br><span class="line">a&amp;=~(<span class="number">0xf</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">a|=(<span class="number">0xa</span>&lt;&lt;<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>4.取地址运算符和解引用运算符：</p><p>1.计算机内存地址都是由32&#x2F;64位二进制数组成，也就是任何地址都是32&#x2F;64位，4&#x2F;8字节</p><p>2.取地址运算符&amp;：获取<strong>一个变量对应的内存首地址</strong>，%p打印</p><p><strong>3.注意：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*&amp;a);</span><br><span class="line"></span><br><span class="line">a=<span class="number">100</span>;</span><br><span class="line">*&amp;a=<span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>两者等价：gcc都翻译为：先获取地址后取内容</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>循环</title>
      <link href="/2022/09/05/%E5%BE%AA%E7%8E%AF/"/>
      <url>/2022/09/05/%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<p>1.{}是否独占一行，由公司的编码规范来定</p><p>比如：linux操作系统程序员规范是不独占一行</p><p>2.switch注意事项</p><p>switch（控制表达式）{</p><p>case 常量表达式：…;</p><p>}</p><p>a)控制表达式被当成一个整数处理（int），可以是字符（本质还是单字节整数），但不能是<strong>浮点数或字符串</strong></p><p>b)常量表达式必须是常量(例如：’a’,5,2+3)，不能是变量，不允许有重复的case分支，分支结构只能是多选一</p><p>c)case分支或者default中如果定义变量，则要加{ }，并且这个变量的作用域只在这个花括号内部</p><p>d)注意break的运用,不管是deafult还是case，后面没跟break的话，都继续向后执行</p><p><strong>swithc…case实现的代码经过gcc编译器翻译的可执行程序代码量比if…else要少，所以switch…case代码执行效率高</strong></p><p>但是switch…case在某些场合使用极其繁琐。而且限制多</p><p>3.循环结构</p><p>for ，while ,do…while</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>进制转换及运算符与表达式</title>
      <link href="/2022/09/05/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E5%8F%8A%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2022/09/05/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E5%8F%8A%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>英文缩写：<br>Bin：二进制<br>Oct：八进制<br>Dec：十进制<br>Hex：十六进制<br>add:加<br>sub:减<br>mul:乘<br>div:除<br>核心已转储:表示程序崩溃了<br>hour：小时<br>minute:分钟<br>second:秒<br>warning: format ‘%d：占位符用的不对！</p><p>回顾：<br>1.变量<br>   作用：就是为了分配内存<br>   语法格式：数据类型 变量名  &#x3D; 初始值;<br>   定义形式:四种形式</p><p>2.标识符<br>   变量名或者函数名统称标识符<br>   第一个字符不能以数字开头,以字母或者下划线<br>   区分大小写<br>   驼峰和下划线</p><p>3.代码风格<br>   该加的空格加空格<br>   该加的TAB键的加TAB键<br>   该独占一行的独占一行<br>   占据屏幕的2&#x2F;3区域</p><p>4.变量的数据类型<br>   作用：预算变量将来分配的内存大小<br>   char&#x2F;unsigned char&#x2F;short&#x2F;unsigned short&#x2F;int&#x2F;unsignd int&#x2F;long&#x2F;unsigned long&#x2F;<br>   long long &#x2F;unsigned long long &#x2F;float &#x2F;double</p><p>5.字符类型<br>   字符常量用’’<br>   本质是整数,ascii码<br>   %c,%hhd<br>   转义字符</p><p>6.int类型<br>   通过short和long修饰可以变形为6中<br>   %d,%ld,%lu等</p><p>7.浮点类型<br>   1.23&#x2F;1.23f<br>   %f,%lf,%g,%lg</p><p>8.整型常数<br>   100&#x2F;100L&#x2F;100UL&#x2F;100LL</p><p>9.scanf输入函数<br>   格式：scanf(格式,变量地址); char c;  scanf(“%c”, &amp;c);printf(“%c %d\n”, c, c);</p><p>10.sizeof关键字<br>     获取变量或者数据类型占用的内存大小<br>     格式：大小&#x3D;sizeof(变量名或者数据类型名)</p><hr><p>11.进制转换<br>11.1.明确：计算机系统中,又将内存的一个字节分为8段,每段只能存0或者1<br>        结论：要想把一个数字存储到字节里,必须首先将这个数字分拆成8个0和1 <br>                  如果一个数字用一个字节存不下,可能需要两个字节或者四个字节<br>     也就是将这个数字分拆成16个0和1或者32个0和1<br>                  所以计算机只认0和1<br>        概念：字节的每一个段有对应的专业术语：bit位,每一段就是一个bit,就是一位<br>                  参见：BIT.png图</p><p>11.2.二进制<br>1)概念：采用一组0或者1表示数字的方法叫二进制表示形式<br>              例如：现在有一个数字90(给人看)<br>                        如果用二进制表示形式为：01011010(给计算机看)<br>2)特点<br>0.二进制和十进制(0,1,2,3,4,5,6,7…)都是表示数字的两种方式<br>   计算机只认二进制,程序员一般用10进制<br>1.计算机只认二进制数字0和1<br>2.二进制表示方式里每个数都有一个编号<br>   例如：编号如下：<br>   7 6 5 4 3  2 1 0  编号（以char为前提）（<strong>要注意前提</strong>）</p><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><strong>一个字节内部的各个位数有高低位之分，不同字节之间也有高低位之分</strong></li></ul></li></ul></li><li><img src="/home/ehe/%E5%9B%BE%E7%89%87/vlcsnap-2022-08-12-14h10m48s776.png"></li></ul></li><li>二进制数<br>3.二进制表示方式里每个1单独代表一个数字,这个数字的只就是2的编号次方<br>7 6 5 4 3  2 1 0  编号<br>0 0 0 1 0  0 0 0<br>结果：00010000这个二进制数对应的数字是2的4次方&#x3D;16(10进制)<br>7 6 5 4 3  2 1 0  编号<br> 0 0 0 1 0  1 0 0<br>结果：00010100这个二进制数对应的数字是2的4次方+2的2次方&#x3D;20(10进制)<br>4.如果两个相邻的二进制内容一样,那么左边的数字是右边数字的2倍<br>7 6 5 4 3  2 1 0  编号<br> 0 0 0 1 1  0 0 0<br>结果：第4位的1代表2的4次方,第3位的1代表2的3次方,那么左边是右边的2倍<br>5.二进制数字加1的时候把编号0位置开始的多个连续的1都变成0,把最左边的0变1<br>例如：<br> 01011111  + 1 &#x3D; 01100000<br>01011110  + 1 &#x3D; 01011111<br>7.用二进制表示的非负数(0和正数)去掉最右边的二进制数字结果相当于这个数字除以2并保留   整数部分<br>例如：<br> 7 6 5 4 3  2 1 0  编号<br> 0 1 1 0 0  1  1 0 二进制数 &#x3D; 102<br> 0 1 1 0  0  1 1 去掉最右边的0以后的二进制数字 &#x3D; 51</li></ul></li></ul></li></ul></li></ul></li></ul><p>3)二进制和十进制之间的转换<br>1.二进制表示的非负数转成十进制的时候就是把每个二进制位的内容单独转换然后求和<br>   例如：<br>   76543210 二进制数编号<br>   01101001 二进制表示形式<br>   结果：转成十进制之后的数值&#x3D;2的6次方+2的5次方+2的3次方+2的0次方<br>                     &#x3D;64+32+8+1&#x3D;105，显然这个数字用1个字节可以存下</p><p>   例如：假如有一个10进制数非常大,显然用char和unsigned char 1字节存不下,用2字节存<br>             于是乎需要将这个数分拆16位,如下：<br>   1514131211109876543210  二进制数编号<br>    0  1  1  0   1  0 1100000011  二进制表示形式<br>   结果：这个数的十进制&#x3D;2的14次方+….&#x3D;</p><p>2.十进制表示的非负数转二进制<br>转换过程：采用”除2取余，逆序排列”法。<br>                 具体做法是：用2整除十进制整数，可以得到一个商和余数；<br>    再用2去除商，又会得到一个商和余数，<br>                 如此进行，直到商为小于1时为止，然后把先得到的余数                 作为二进制数的低位(0开始)，后得到的余数作为二进制数的高位，依次排列起来。</p><p>例如：91这个十进制转二进制<br>91&#x2F;2&#x3D;45    余1<br>45&#x2F;2&#x3D;22    余1<br>22&#x2F;2&#x3D;11    余0<br>11&#x2F;2&#x3D;5      余1<br>5&#x2F;2&#x3D;2  余1<br>2&#x2F;2&#x3D;1  余0<br>1&#x2F;2&#x3D;0  余1<br>0&#x2F;2&#x3D;0         余0<br>结果：91二进制数&#x3D;01011011</p><p>如：255转二进制<br>255&#x2F;2&#x3D;127&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;余1<br>127&#x2F;2&#x3D;63&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;余1<br>63&#x2F;2&#x3D;31&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;余1<br>31&#x2F;2&#x3D;15&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;余1<br>15&#x2F;2&#x3D;7&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;余1<br>7&#x2F;2&#x3D;3&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;余1<br>3&#x2F;2&#x3D;1&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;余1<br>1&#x2F;2&#x3D;0&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;余1<br>结果：255二进制&#x3D;111111111</p><p>789二进制为:1100010101<br>789&#x2F;2&#x3D;394 余1<br>394&#x2F;2&#x3D;197 余0<br>197&#x2F;2&#x3D;98 余1<br>98&#x2F;2&#x3D;49 余0<br>49&#x2F;2&#x3D;24 余1<br>24&#x2F;2&#x3D;12 余0<br>12&#x2F;2&#x3D;6 余0<br>6&#x2F;2&#x3D;3 余0<br>3&#x2F;2&#x3D;1 余1<br>1&#x2F;2&#x3D;0 余1 </p><p><strong>一定要算到商为0的时候</strong></p><p>这里可以类比到二进制数右移，右移一位后保留的数就是这里的商。被移除的最低位的数就是这里的余数</p><p>3.负数的十进制和二进制之间不可直接转换,必须借助相反数<br>   负数的十进制转二进制的步骤,三步骤：<br>   1.首先计算出<strong>负数的相反数</strong><br>   2.然后把得到的相反数转换<strong>成二进制数</strong><br>   3.最后对转换之后的<strong>二进制数据取反(1-&gt;0,0-&gt;1)<strong>后再</strong>加1</strong><br>   例如：-14转二进制**<br>   1.计算相反数：14<br>   2.转成14的二进制：00001110<br>   3.取反加1：11110001 + 1 &#x3D; 11110010</p><p><strong>负数二进制转换为十进制：减1 二进制取反  再取相反数</strong></p><p>4.有符号类型数字采用符号<br>   二进制数字最左边的位叫符号位<br>   它的值可以用来确定数字的符号<br>   符号位的值是0表示这个数字是非负数(0或者正数)<br>   符号位的值是1表示这个数字是负数<br>   例如：现在有这么一个8位的二进制数：01011010,此二进制对应的十进制数为非负数<br>             现在有这么一个8位的二进制数：11011010,此二进制对应的十进制数为负数<br>             现在有这么一个16位的二进制数：<br>       0101010101011010,此二进制对应的十进制数为非负数<br>              现在有这么一个16位的二进制数：<br>       1101010101011010,此二进制对应的十进制数为负数<br>              现在有这么一个16位的二进制数：<br>                   01011010,此二进制对应的十进制数为非负数 &#x2F;&#x2F;高8位都是0<br>              现在有这么一个16位的二进制数：<br>                   11011010,此二进制对应的十进制数为非负数 &#x2F;&#x2F;高8位都是0<br>              现在有这么一个16位的二进制数：<br>    1111111111011010,此二进制对应的十进制数为负数<br>  例如：<br>  目前有这么一个二进制数是：10110110(前提是：如果作为字符类型数字此数必然是负数)<br>  要求计算这个二进制对应的十进制的负数为：<br>  1.先求反在加1：01001001 + 1 &#x3D; 01001010<br>  2.然后计算转换之后的二进制对应的十进制<br>     01001010&#x3D;2的6次方+2的3次方+2的1次方&#x3D;74<br>  3.最后求相反数结果为-74</p><p>4)二进制和八进制的故事<br>1.八进制定义：就是把二进制数字从右到左每三个数为一组<br>                        每组用一个0和7之间的数字替换得到8进制表示形式<br>   例如：<br>   原始二进制数：01101010<br>   按照8进制分组：01 101  010<br>   然后对分组的数求值:<br>         01&#x3D;2的0次方&#x3D;1<br>         101&#x3D;2的2次方+2的0次方&#x3D;5<br>         010&#x3D;2的1次方&#x3D;2<br>   结果是01101010二进制数对应的八进制数为152(八进制)</p><p>2.八进制特点<br>   程序中可以直接使用八进制数,但是这种数字必须以0开头(例如：0152)<br>   对应的占位符是0%o，将来在屏幕上就可以看到这个八进制数的形式<br>   例如：<br>   int a &#x3D; 106; &#x2F;&#x2F;10进制数<br>   printf(“十进制数值是：%d,其八进制数值是：0%o\n”, a, a);</p><p>5)二进制和十六进制的故事(核心中的核心)<br>1.定义：把二进制数所有的位数从右到左每4位为一组<br>             每组用一个字符替换(用a到f之间的字母替换10~15之间数字)<br>             这种表示方式简称十六进制<br>             注意：16进制数必须以0x开头,不用区分大小写<br>   结论：<strong>程序中将来所有的二进制建议都是以16进制形式表示</strong>,不建议用10进制和8进制<br>   例如：<br>   原始二进制：11000101<br>   分组：1100  0101<br>   换算 :  12        5<br>   替换    c           5<br>   结果：此二进制对应的16进制为0xc5 </p><p>2.特点<br>   1.必须以0x或者0X开头<br>   2.占位符：%#x(字母按小写显示)&#x2F;%#X(字母按大写显示)<br>   3.切记：务必拿下二进制和十六进制的转换,开发必用！<br>   例如：背下来,否则遭鄙视<br>    十六进制二进制<br>    00000<br>    10001<br>    20010<br>    30011<br>    40100<br>    50101<br>    60110<br>    70111<br>    81000<br>    91001<br>    a1010<br>    b1011<br>      c1100<br>    d1101<br>    e1110<br>    f1111<br>例如：<br>二进制十六进制<br>11000101 0xc5<br>01011010 0x5A<br>11000011 0xc3<br>0001 1000 0101 11100x185e<br>十六进制二进制<br>0xa541010 0101 0100<br>0xb81011 1000<br>0x5a69cd380101 1010 0110 1001 1100 1101 0011 1000<br>3.总结：程序中不管用10进制也好,8进制也好,还是16进制也是,他们都是对内存中<br>             存储的二进制数的不同表达方式而已,不管哪种方式,最终内存存的二进制数都是一样的</p><hr><p>12.运算符和表达式<br>12.1.定义<br>        运算符：就是对内存中的数据进行操作的符号，例如：加法运算符+<br>        表达式：就是数据和运算符结合起来的式子,例如：1+2<br>1.2.C语言相关的运算符<br>1)算数运算符：加减乘除取余:+,-,*,&#x2F;,%<br>   注意：<br>   1.如果参与除法运算的两个数字都是整数则计算结果只保留整数部分,例如：5&#x2F;2&#x3D;2<br>   2.&#x2F;和%不能对整数0进行操作,否则程序中断失败,例如：5&#x2F;0:报错<br>   3.%不能用于浮点数,例如：5%1.2,报错<br>   4.%的结果与其左边的数字的符号一致,例如：-7%2&#x3D;-1 7%-2&#x3D;1<br>   5.&#x2F;如果除数为浮点数,最后得到inf无穷大</p><p>案例：输入一个秒收,打印对应的小时,分钟和秒数<br>例如：3600-&gt;1小时0分0秒<br>          3601-&gt;1小时0分1秒<br>          公式：<br>          小时&#x3D;秒数&#x2F;3600<br>          分钟&#x3D;秒数%3600&#x2F;60<br>          秒&#x3D;秒数%60</p><p>2）赋值运算符:”&#x3D;”<br>功能：将运算符右边的数字给左边的变量<br>形式1：<br>int a;<br>a &#x3D; 10; </p><p>形式2：<br>int a, b, c;<br>a &#x3D; b &#x3D; c &#x3D; 0x10; </p><p>2.切记：赋值运算符”&#x3D;”不是”&#x3D;&#x3D;”</p><p>3.赋值运算符和其他运算符结合起来使用,构成复合运算符<br>   例如：<br>   a +&#x3D; b; &#x2F;&#x2F;a &#x3D; a + b;<br>   a -&#x3D; b; &#x2F;&#x2F;a &#x3D; a-b<br>   a <em>&#x3D; b; &#x2F;&#x2F;a &#x3D; a</em>b;<br>   a &#x2F;&#x3D; b;  &#x2F;&#x2F;a &#x3D; a&#x2F;b;<br>   a %&#x3D;b; &#x2F;&#x2F;a &#x3D; a%b;<br>   等等</p><p>4.不能给常量和表达式赋值<br>   例如：100 &#x3D; 200; &#x2F;&#x2F;报错<br>             100 &#x3D; a; &#x2F;&#x2F;报错<br>             a + b &#x3D; c; &#x2F;&#x2F;报错</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>基础知识及一些基础指令</title>
      <link href="/2022/09/05/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4/"/>
      <url>/2022/09/05/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>英文：<br>read:读,r字母<br>write:写,w字母<br>execute:执行,运行,x字母<br>directory:目录,d字母</p><p>1.自我介绍<br>   游成伟<br>   15801588497<br>   <a href="mailto:&#x34;&#x30;&#x39;&#x30;&#x32;&#53;&#x32;&#x36;&#x30;&#64;&#x71;&#113;&#46;&#x63;&#x6f;&#x6d;">&#x34;&#x30;&#x39;&#x30;&#x32;&#53;&#x32;&#x36;&#x30;&#64;&#x71;&#113;&#46;&#x63;&#x6f;&#x6d;</a></p><p>2.计算机组成部分：硬件和软件<br>2.1.硬件<br>1)必要的三大件<br>   1.CPU<br>       核心的两大功能：<br>    1.数据运算，例如：1+1&#x3D;2<br>    2.外设控制,从外设拿到数据(读数据,read)或者向外设发送数据(写数据,write)<br>       问：何为外设？<br>       答：除了CPU其他任何硬件<br>   2.内存：用于暂存CPU计算时(1)或者计算之后的数据(2)<br>                特点：数据可以进行无限的覆盖<br>                缺点：掉电数据丢失(就是重启或者断电)<br>                优点：数据的读或者写速度非常快(比CPU慢,比硬盘快)<br>   3.硬盘(统称为闪存)：用于永久性保存数据<br>               特点：数据也可进行无限的覆盖<br>               缺点：数据的读或者写操作太慢了,所以数据操作一般都要先从硬盘拷贝到内存<br>           再从内存进行操作,这样速度能够提高不少<br>               优点：数据永久性不丢失,也就是掉电数据不丢失<br>2)其余可选硬件<br>   鼠标,键盘,显示器,显卡等</p><p>2.2.软件：三大部分<br>1)操作系统<br>   功能：通过驱动程序来管理各种硬件和管理各种应用软件(CPU分配,内存分配等)<br>2)命令行软件(专业术语叫shell终端)<br>   功能：接收到用户输入的各种命令,然后让CPU执行这些运行处理这些命令<br>             例如：windows终端输入notepad命令,最终能够打开一个记事本<br>3)各种应用程序：QQ,吃鸡,喝农药,百度浏览器等</p><p>3.主流的操作系统<br>   windows:微软<br>   linux：开源(免费和付费)，推荐三大主流linux系统：<br>               ubuntu(推荐,64位,版本：18.04 ),fedora,kali(黑客最爱)<br>   苹果：MAC IOS<br>   安卓:本质就是linux<br>   vxwork:付费(硬实时操作系统,以上linux,windows等都是软实时操作系统)<br>4.linux系统发展(设计思想参考unix)<br>   开源免费<br>   1991年正式发布<br>   linux内核之父：linus<br>   推荐linux发展视频:&lt;<the code linux>&gt;</p><p>5.linux系统特点<br>   linux系统理念(信仰):一切皆文件<br>   一切皆文件：在linux系统中,任何硬件外设都是以文件的形式存在,一个应用程序例如QQ访问<br>                        显示器,只需访问这个显示器硬件对应的文件即可<br>         文件即硬件,硬件皆文件<br>  问：linux系统中文件如何管理呢？<br>  答：靠文件系统(仅仅是一个名词)来管理文件<br>         不同的文件系统管理文件的方式方法不一样<br>          例如：硬盘一般用NTFS文件系统一(管理的文件大小无限制）<br>      U盘一般用FAT32文件系统(管理的单个文件不要超过4GB)<br>      内存一般用SYSFS文件系统(管理的文件都是位于内存中,掉电丢失)</p><p>6.linux系统中跟文件和目录(也是一种特殊的文件,俗称文件夹)相关的概念<br>6.1.目录：能够包含其他目录和文件<br>6.2.根目录：文件系统中最上一层的目录,用”&#x2F;“表示<br>                    也就是linux系统中所有的目录和文件他们都是位于”&#x2F;“根目录下<br>                    例如：&#x2F;home(语义：在根目录下有一个home目录或者一个home文件)<br>6.3.子目录：位于其他目录下的目录<br>     例如：&#x2F;home(语义：假如home是一个目录名,home就是根目录’&#x2F;‘的子目录)<br>               &#x2F;home&#x2F;tarena:假如tarena是一个目录名,tarena就是home子目录<br>            其中第二个’&#x2F;‘表示分割<br>6.4.父目录：子目录的上一层目录<br>    例如：&#x2F;home:根目录‘&#x2F;’就是home子目录的父目录<br>6.5.当前目录(又称工作目录)：当前正在使用或者所在的目录,用’.’表示<br>    例如：.&#x2F;home:当前目录下有一个home目录或者文件<br>      上一级目录：当前目录的父目录,用”..”表示<br>                   例如：..&#x2F;..&#x2F;:上一级的上一级目录<br>6.6.主目录：登录linux系统时,需要一个用户,linux系统给这个用户专门指定了一个专有的目录<br>     此目录简称主目录,并且都是位于&#x2F;home&#x2F;目录下,用”~”表示<br>                   例如：登录linux系统的用户名叫tarena,tarena用户的主目录：&#x2F;home&#x2F;tarena<br>                             登录linux系统的用户名叫zhangsan,zhangsan用户的主目录：&#x2F;home&#x2F;zhangsan<br>6.7.路径：目录和文件的位置,又分两种：<br>      绝对路径：以”&#x2F;“开头的路径表示形式<br>        例如：&#x2F;home&#x2F;tarena<br>      相对路径：不以”&#x2F;“开头的路径表示形式<br>                       例如：home&#x2F;tarena或者.&#x2F;home&#x2F;tarena或者..&#x2F;..&#x2F;<br>      由衷建议：以后软件代码中最好写绝对路径<br>      open(“my.txt”); &#x2F;&#x2F;前提是程序运行之前必须先进入my.txt文件所在的目录下,否则打开open失败<br>      或者<br>      open(“&#x2F;dev&#x2F;my.txt”)；&#x2F;&#x2F;爱在哪个目录下就在哪个目录下</p><p>7.掌握linux系统必要命令：<br>   建议：通过输入各种命令替代图形界面操作方式<br>  命令格式：命令名   选项<br>7.1)pwd:获取当前所在路径<br>7.2)ls:获取目录和文件的信息<br>形式1：<br>   ls -lh   &#x2F;&#x2F;获取当前目录下所有的目录和文件的详细信息<br>形式2：<br>   ls -lh  文件名 &#x2F;&#x2F;获取此文件的详细信息<br>   例如：<br>   ls -lh &#x2F;home&#x2F;tarena&#x2F;qw.c 得到以下信息：<br>      -rwxrw-r– 1 tarena tarena 70 Jun 25 16:36 qw.c<br>      说明：<br>      ‘-‘:表示此文件就是一个普通的文件<br>      ‘rwx’:表示当前登录linux的用户对此文件可以读(查看文件),可以写(向文件写入信息),可执行<br>      ‘rw-‘:表示当前登录linux的用户所在的组对此文件可以读,可以写,不可执行运行<br>      ‘r–’:表示其他的linux用户对此文件可以读,不可写,不可执行<br>      ‘1’：表示硬连接数(不关注)<br>      ‘tarena’:表示当前登录linux系统的用户名<br>      ‘tarena’:表示tarena用户所在的组<br>      ‘70’:表示此文件大小为70个字节<br>      “Jun 25 16:36”:文件的创建日期<br>     ‘qw.c’：文件名</p><p>7.3)clear:清屏命令<br>7.4)cd:切换路径：cd &#x2F;home&#x2F;tarena<br>7.5)mkdir:创建目录：mkdir -p &#x2F;home&#x2F;tarena&#x2F;hello&#x2F;hello1<br>7.6)touch:创建空文件：touch &#x2F;home&#x2F;tarena&#x2F;hello.txt<br>7.7)rm:删除目录和文件: rm -fr &#x2F;home&#x2F;tarena&#x2F;hello<br>7.8)cp:文件或者目录拷贝：cp -fr 源文件 新文件<br>              cp -fr 源目录 新目录<br>       注意：cp hello.txt hello&#x2F;<br>       分3种：<br>       1.hello是一个目录并且存在,就是将hello.txt拷贝一份到hello目录下<br>       2.hello是一个目录并且不存在,命令cp报错<br>       3.hello是你想象的,你认为的目录但是不存在,并且命令形式:cp hello.txt hello 就是一个文件的拷贝<br>       切记：只要是目录操作,建议最后一定加分隔符’&#x2F;‘，来区分是目录还是文件<br>                  建议每次输入命令,用TAB键来补全,也会顺便给你添加’&#x2F;‘<br>7.9)mv:移动,剪切</p><p>快捷方式：<br>    Alt + Ctrl + t  快速打开一个新的终端</p><pre><code>ctrl + shift + t 在终端里打开新的窗口    alt + 数字键 在不同的窗口间切换ctrl + shift + =  放大字体ctrl + -  字体缩小tab键  快速补全ctrl + l 快速清屏F11 窗口最大化</code></pre><hr><p>7.10)cat 命令：快速查看文件的内容<br>    例如：cat hello.txt</p><p>7.11)echo命令：向显示器打印输出数据命令<br>                            例如：echo  “我是大神”或者echo 我是大神<br>         注意：此命令一般配合”&gt;”和”&gt;&gt;”(统称重定向符)<br>         例如：<br>         cd &#x2F;home&#x2F;tarena&#x2F;<br>         touch hello.txt<br>         echo 我是大神 &gt; hello.txt  意思是：先将hello.txt文件内容删除,然后将新内容写入到文件<br>         cat  hello.txt<br>         echo 我是小神 &gt;&gt; hello.txt 意思是：将新内容追加到文件的后面<br>         cat hello.txt</p><p>7.12)find命令：到某个指定的路径下找文件或者目录<br>         格式：find 路径  -name 要找的文件名<br>         例如：find &#x2F;usr&#x2F;include  -name stdio.h<br>         语义：到&#x2F;usr&#x2F;include目录下找一个文件名为stdio.h这个文件</p><p>7.13)grep命令：到某个路径下的某个文件中搜索字符串<br>        例如：grep “我是大神”  *  -Rn<br>        语义：在当前目录下的所有文件中搜索我是大神字符串<br>        “*”:表示全部文件<br>        “-Rn”:到子目录下也同样搜索,并且打印字符串所在的行号</p><p>7.14)linux系统解压缩的三条终极命令：<br>         linux常用的两种压缩格式:bz2和gz<br>        压缩命令：<br>        tar -jcvf  压缩包.tar.bz2  目录或者文件<br>        tar -zcvf 压缩包.tar.gz   目录或者文件<br>        解压缩：<br>        tar -xvf 压缩包.tar.bz2 &#x2F; 压缩包.tar.gz<br>        例如：<br>         cd &#x2F;home&#x2F;tarena&#x2F;<br>         mkdir hello<br>         touch hello.txt<br>         echo 我是大神 &gt; hello.txt<br>         cat  hello.txt<br>         echo 我是小神 &gt;&gt; hello.txt<br>         cat hello.txt<br>         mv hello.txt  hello&#x2F;<br>         tar -jcvf hello.tar.bz2 hello&#x2F; &#x2F;&#x2F;把hello目录压缩成hello.tar.bz2压缩包<br>         tar -zcvf hello.tar.gz hello&#x2F; &#x2F;&#x2F;&#x2F;把hello目录压缩成hello.tar.gz压缩包<br>         tar -xvf hello.tar.bz2<br>         tar -xvf hello.tar.gz</p><p>​                   </p><p>​     </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>继续运算符及流程控制</title>
      <link href="/2022/09/05/%E7%BB%A7%E7%BB%AD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%8A%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
      <url>/2022/09/05/%E7%BB%A7%E7%BB%AD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%8A%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>priority:优先级</p><p>回顾：<br>1.公式：</p><p>位清0：A &amp;&#x3D;~(B&lt;&lt;C)</p><p>位置1：A|&#x3D;(B&lt;&lt;C)</p><p>对多位操作时，综合两者使用，可以先将目标位清0，再通过|&#x3D;插入需要的二进制数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">0xaacc7654</span>;</span><br><span class="line"></span><br><span class="line">a&amp;=~(<span class="number">0xff</span>&lt;&lt;<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">a|=(<span class="number">0xaa</span>&lt;&lt;<span class="number">16</span>);</span><br></pre></td></tr></table></figure><p>以上例子：把cc位变为aa</p><p>今天：</p><p>1.条件运算符</p><p>a?b:c</p><p>2.运算符优先级</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=(<span class="number">1</span>&gt;<span class="number">2</span>)&amp;&amp;(<span class="number">2</span>&lt;<span class="number">3</span>);<span class="comment">//写括号，提高代码可读性</span></span><br></pre></td></tr></table></figure><p>3.数据类型的转换：<strong>隐式转换和强制转换</strong></p><p>3.1隐式转换特点：如果表达式中不同数字的数据类型不同，gcc编译器<strong>自动</strong>先将不同的数据类型转换成<strong>相同的数据类型</strong>之后再做运算</p><p>隐式转换三种情形：</p><p><strong>运算表达式中存在多种数据类型时</strong></p><p>a)gcc会把占内存小的类型转换成占内存大的类型</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a=0;</span><br><span class="line">char b=2;</span><br><span class="line">c=a+b;//gcc编译器自动将b的数据类型转换成int类型，再计算结果给c</span><br></pre></td></tr></table></figure><p>b)如果有整型数据类型和浮点数类型，gcc会把整型数据转换为浮点数类型</p><p>c)如果既有有符号数，又有无符号数，gcc编译器会自动将有符号数转换为无符号类型</p><p><strong>d)不推荐使用隐式转换，代码可读性差</strong></p><p>e)<strong>规律：小转大，整转浮，有转无（符号）</strong></p><p>注意：</p><p>1.sizeof(1?1:0.9);&#x2F;&#x2F;结果是8  这里浮点数和整型类型都有，隐式转换，double为8字节</p><p>2.<strong>问题</strong>：这个的结果不该是一个很大的数吗（2^32–7），为什么我的输出都是-4</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="number">-7</span>+<span class="number">3u</span>);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="number">-7</span>转换成无符号数：<span class="number">2</span>^<span class="number">32</span><span class="number">-7</span></span><br></pre></td></tr></table></figure><p>解答：这里的占位符有问题，%d的输出要求把3u转成int了，应该为%u</p><p>3.2强制转换（推荐使用，目的：提高代码可读性）</p><p>a)语法：目标类型变量&#x3D;（目标类型）源类型变量</p><p><strong>例如：char a&#x3D;90;</strong></p><p><strong>int b&#x3D;a;&#x2F;&#x2F;隐式转换</strong></p><p><strong>int b&#x3D;(int)a;&#x2F;&#x2F;强转为int类型</strong></p><p>b)注意：<strong>强转可能会造成数据的丢失</strong></p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a =<span class="number">300</span>;</span><br><span class="line"><span class="type">char</span> b=(<span class="type">char</span>)<span class="number">300</span>;<span class="comment">//输出b为44</span></span><br></pre></td></tr></table></figure><p><strong>为什么：</strong></p><p><strong>300正向溢出了边界，溢出173，由于是正向，从左边界开始结算，所以结果是-128+173&#x3D;45，是从0开始的第45个</strong></p><p><strong>所以是44</strong></p><p>所以：强转数据类型转换都是小转大，或者相等转（意思是这两种可以被允许），隐式转换也遵循此规则，否则也会数据丢失</p><p><strong>c)不管哪种类型转换都不会改变变量本身值</strong></p><h2 id="c语言流程控制"><a href="#c语言流程控制" class="headerlink" title="c语言流程控制"></a>c语言流程控制</h2><p>1.明确：c程序是一个结构化程序，由顺序结构、分支结构、循环结构构建的单入口（main）和单出口的程序（return 0）；</p><p>2.分支结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>（<span class="number">1</span>==a）&#123;<span class="comment">//这样写更好,1在前，避免把相等关系号写成赋值号，因为写成a=1也是能执行的，而写成1=a必然报错</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a等于1\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>gcc编译器默认不链接math库，我们在编译时要手动链接</p><p><strong>分步式：</strong>test.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -E -o test.i test.c;</span><br><span class="line">gcc -c -o test.o test.i;</span><br><span class="line">gcc -o test test.o -lm;<span class="comment">//这里-l是链接选项</span></span><br><span class="line">                       <span class="comment">// m 是math库</span></span><br></pre></td></tr></table></figure><p>懒人式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o test test.c -lm;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>变量及数据类型</title>
      <link href="/2022/09/05/%E5%8F%98%E9%87%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2022/09/05/%E5%8F%98%E9%87%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>variable:变量，var<br>char:字符,例如：’a’,’A’等<br>B:Byte:字节,1字节<br>W:Word:字,4字节<br>H:Half：一半<br>HW:HalfWord:半字,2字节<br>DW:DoubleWord:双字，8字节<br>type：类型<br>circle：圆<br>rectangle:矩形<br>ellipse：椭圆<br>radius：半径</p><p>回顾：variable:变量<br>char:字符,例如：’a’,’A’等<br>B:Byte:字节,1字节<br>W:Word:字,4字节<br>H:Half：一半<br>HW:HalfWord:半字,2字节<br>DW:DoubleWord:双字，8字节<br>type：类型<br>circle：圆<br>rectangle:矩形<br>ellipse：椭圆<br>radius：半径</p><p>回顾：<br>1.linux命令<br>   ls&#x2F;cd&#x2F;pwd&#x2F;clear&#x2F;mkdir&#x2F;touch&#x2F;cat&#x2F;echo&#x2F;tar&#x2F;cp&#x2F;mv&#x2F;grep&#x2F;find&#x2F;whoami<br>2.vim编辑器<br>   三种模式,模式切换,快捷键,命令行模式下的命令<br>3.C语言编程基础<br>   源文件.c&#x2F;头文件.h<br>   至少有一个源文件<br>   至少有一个main函数<br>   main函数形式：<br>   int main(void)<br>   {<br>           return 0; &#x2F;&#x2F;结束返回,程序执行到这里结束<br>   }<br>   为了用printf函数需要添加头文件<br>   头文件包含形式两种：#include &lt;stdio.h&gt;&#x2F;#include “stdio.h”<br>   注释形式两种：&#x2F;**&#x2F;,&#x2F;&#x2F;<br>   CPU先找main函数,一旦找到从上往下挨个每条语句执行<br>4.printf函数<br>   功能：向显示器上输入信息<br>   占位符：%d<br>   必须包含：#include &lt;stdio.h&gt;<br>5.C程序编译：必须用gcc编译器(翻译官)<br>   翻译三步骤：预处理&#x2F;编译&#x2F;链接<br>   C程序编译的三种方式：<br>   gcc  xxx.c<br>   gcc -E .c -o .i<br>   gcc -c .i -o .o<br>   gcc -o 目标 .o<br>   gcc -o 目标 .c<br>6.内存特性<br>   研究程序最终研究程序对应的内存(排兵布阵)</p><h2 id="概念：字节-地址-存储区-首地址"><a href="#概念：字节-地址-存储区-首地址" class="headerlink" title="   概念：字节,地址,存储区,首地址"></a>   概念：字节,地址,存储区,首地址</h2><p>7.C语言基础之变量<br>7.1.问：既然程序玩的是内存,那么程序如何从内存分配存储区的空间呢？<br>      答：通过变量来实现内存的分配(类似开房)<br>7.2.变量定义的语法格式：<br>      切记：何为定义？答：定义就是分配内存<br>                何为初始化？答：就是给变量对应的内存空间放一个数字<br>      语法： 数据类型  变量名 &#x3D; 初始值;<br>      注意：目前掌握一个数据类型：int(整型数:0,1,2,3…)，表示分配4字节内存空间<br>              此种数据类型的占位符：%d<br>              例如：printf(“%d\n”, 变量名);<br>      定义变量的形式：<br>      形式1：只定义不初始化<br>      int  var;  语义：定义变量var,本质就是让操作系统给你分配一块内存空间来存储数字<br>                  并且这块内存空间叫var名称,将来访问var名称就是在访问内存空间<br>                  并且这块内存空间的大小连续4字节,并且这4个字节的内存空间<br>                               的数字将来可以随时改变<br>                  注意：此时这块内存空间存储的是一个随机乱七八糟的数字<br>      形式2：定义的同时并且初始化<br>      int var &#x3D; 250; &#x2F;&#x2F;分配4字节内存空间并且同时往里面放一个250数字</p><pre><code>  形式3：定义之后再初始化  int var;  var = 250;  形式3：连续只定义多个变量  int var1, var2, var3; //定义三个变量var1,var2,var3  形式4：连续定义并且初始化  int var1 = 250, var2 = 251, var3 = 252;  形式5：连续定义多个变量之后再初始化  int var1, var2, var3;  var1 = 250;  var2 = 251;  var3 = 252;</code></pre><p>7.3.问：变量名是否可以随意起名？<br>      答：变量名(var)和函数名(printf)在C语言中统称标识符(用来区分,标识的符号)<br>             标识符的名称规则：<br>             1.不能以数字开头,第一个字符只能以字母和下划线开头,后面可以有数字<br>                例如：int 2var; &#x2F;&#x2F;错误<br>             int var2; &#x2F;&#x2F;可以<br>             2.标识符不能用关键字(有特殊功能含义的单词)<br>                目前掌握的关键字如下：include, int, void, main, return<br>                例如：int int; &#x2F;&#x2F;错误<br>             3.要区分大小写<br>                例如：int var 不等于 int Var;<br>             4.采用驼峰或者下划线命名<br>                驼峰：int nAge;<br>             int CreateWindows<br>                linux程序员基本采用下划线命名：int create_windows;<br>7.4.问：写C语言代码书写格式可以任意吗？<br>      答：理论上随意,但是还要讲究美观<br>      1.int main(void) {printf(“hello,world\n”); return 0;} &#x2F;&#x2F;没毛病,太难看了<br>         该加空格的加空格,TAB键的TAB键,对齐,缩进都有讲究,让代码看起来美观<br>         int main(void)<br>         {  &#x2F;&#x2F;独占一行<br>    printf(“….”); &#x2F;&#x2F;一条语句占一行<br>    return 0;  &#x2F;&#x2F;一条语句占一行<br>         } &#x2F;&#x2F;独占一行<br>      2.代码编写区域建议显示器左侧2&#x2F;3,如果超过了,换行写<br>         printf(“%d %d %d %d %d %d %d %d %d”,<br>            1, 2, 3,4,5,6,7,8,9,10);<br>         printf(“%d %d %d %d %d %d %d”<br>      “%d %d %d %d %d %d %d\n”, </p><pre><code>    1, 2, 3,4,5,6,7,8,9,10);</code></pre><hr><p>8.变量的数据类型<br>8.1.数据类型的作用：让编译器gcc预算变量将来要分配的内存大小<br>        不同的数据类型将来分配的内存大小不一样<br>8.2.C语言的基本数据类型：<br>      关键字                   含义             分配内存大小         数字范围<br>      char           字符类型(本质单字节的整数)            1字节              -128<del>127(背)<br>   unsigned char      无符号单字节整数     1字节               0</del>255(背)<br>     short                   双字节整数     2字节              -32768<del>32767<br>   unsigned short    无符号双字节整数     2字节              0</del>65535<br>     int                       四字节整数     4字节     -2^31 <del>2^31-1<br>   unsigned int        无符号四字节整数     4字节        0</del>2^32-1<br>     long                    四字节整数     4字节     -2^31 <del>2^31-1<br>   unsigned long    无符号四字节整数     4字节        0</del>2^32-1<br>     long long          八字节整数     8字节     -2^63 <del>2^63-1<br>   unsigned long long    无符号八字节整数     8字节        0</del>2^64-1<br>    float              单精度浮点数     4字节        很大<br>    double               双精度浮点数     8字节        很大</p><p>8.3.有符号和无符号之分<br>1)每种数据类型都有有符号和无符号之分<br>2)有符号数据有正负之分,可以用signed关键字来修饰,也可以不用写<br>    例如：<br>    int var &#x3D; 250;<br>    等价于<br>    signed int var &#x3D; 250;<br>3)无符号数据只有0和正数,必须用unsigned关键字修饰<br>    unsigned int var &#x3D; 250; </p><p>8.4.切记：unsigned int和unsigned long<br>      对于32位&#x2F;64操作系统,unsigned int分配的内存就是4字节<br>      对于32位操作系统,unsigned long分配的内存就是4字节<br>      对于64位操作系统,unsigned long分配的内存就是8字节<br>      结论：如果将来用一个变量来保存内存的某个地址,一定要用unsigned long<br>                后续指针课程再来理解！</p><p>8.5.基本数据类型详解之char(字符)<br>常量：其值不可改变,例如：250<br>1)字符常量用单引号’’括起来,例如:’A’,’a’<br>    区分大小写<br>2)本质：字符类型的变量对应的内存本质上存储的就是字符常量对应的一个整数(数字)而已，<br>              这个数字有对应的专业术语叫<strong>ascii码</strong><br>              说明：字符和整数之间可以互转<br>              例如：<br>          字符      整数<br>          ‘A’         65<br>          ‘B’  66<br>          ‘a’  97<br>                       ‘b’  98<br>          …  …<br>          所以:’d’-‘a’ &#x3D; 本质就是 100-97&#x3D;3<br>3)字符类型变量的占位符：%c,%d<br>   例如：<br>   char c &#x3D; ‘A’; &#x2F;&#x2F;<strong>表面看</strong>定义字符变量c并且初始化为字符常量’A’<br>           &#x2F;&#x2F;<strong>看清本质</strong>：就是分配1字节内存空间,并且往这个内存空间放了<strong>一个数字65</strong><br>   printf(“c &#x3D; %c\n”, c); &#x2F;&#x2F;打印输出按字符格式输出，c&#x3D;’A’<br>   printf(“c &#x3D; %d\n”, c); &#x2F;&#x2F;打印输出按照整数格式输出,c&#x3D;65</p><p>4)转义字符(特殊字符)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x27;\n&#x27;:换行符,将光标移动到下一行的行首</span><br><span class="line"> &#x27;\r&#x27;:回车符,将光标移动到当前行的行首</span><br><span class="line"> &#x27;\t&#x27;:TAB键</span><br><span class="line"> &#x27;\\&#x27;:输出一个\</span><br><span class="line"> &#x27; \&#x27;&#x27;:输出一个&#x27;</span><br><span class="line"> &#x27;\&quot;&#x27;:输出一个&quot;</span><br><span class="line"> &#x27;%%&#x27;:输出一个%</span><br><span class="line"> 例如：利用printf要求向屏幕上输出这些信息：</span><br><span class="line"> abc</span><br><span class="line">(TAB键)cbd\&#x27;efg&#x27;\&quot;hjk&quot;\%</span><br><span class="line">答案：printf(&quot;abc\n\tcbd\\\&#x27;efg\&#x27;\\\&quot;hjk\&quot;\\%%\n&quot;);</span><br></pre></td></tr></table></figure><p>8.6.基本数据类型详解之整型数据类型(int)<br>1)int特点：<br>   int代表2字节或者4字节整数<br>   可以用short或者long进行修饰,最终得到6大形势,也就是上面表格的内容<br>2)int的六种形式：<br>   1.short (int)用2字节表示,有符号   &#x2F;&#x2F;这里意思是 int可不加<br>      例如：<br>    short  int a &#x3D; 250;<br>    等价于<br>    short a &#x3D; 250;<br>   2.unsigned short (int)用2字节表示,无符号<br>      例如：<br>               unsigned short int a &#x3D; 250;<br>               等价于<br>               unsigned short a &#x3D; 250;<br>  3.long (int)用4字节表示,有符号<br>     例如：long int a &#x3D; 250;<br>               等价于<br>               long a  &#x3D; 250;<br>  4.unsigned long (int)用4字节表示,无符号<br>     例如：unsigned long int a &#x3D; 250;<br>               等价于unsigned long a &#x3D; 250;<br>  5.int用4字节表示,有符号<br>     例如：int a  &#x3D; 250;<br>  6.unsigned int用4字节表示,无符号<br>     例如：unsigned int a &#x3D; 250;</p><p><strong>long long也能修饰int</strong></p><p>long long int   就是long long  </p><p>8.7.整型常数(细腻,高薪)<br>      100：gcc编译器默认当成int类型<br>      100L:gcc编译器当成long类型<br>      100LL:gcc编译器当成long long类型<br>      100u:gcc编译器当成unsigned int类型<br>      100UL：gcc编译器当成unsigned long类型(最爱)<br>      用途：用于后期课程的数据类型的转换用</p><p>8.8.基本数据类型详解之浮点数类型<br>      float&#x2F;double<br>      例如：<br>      1.23:gcc编译器默认当double类型,8字节<br>      1.23f:gcc编译器当float类型,4字节<br>      注意：浮点数在计算机中都是近似值(差不多得了)<br>                例如：1.23实际是1.2300001</p><p>8.9.数据类型和占位符之间的故事<br>      数据类型       占位符<br>      char             %c(字符显示)和%hhd(整型数显示)（这个更精确）</p><p> %d 是int 的占位符 ，老师把它和字（word）扯上关系，那64位系统中%d岂不是占八位？？？</p><p><strong>另外：没有%hhhd</strong></p><p>​     unsigned char    %c(字符显示)和%hhd(整型数显示)<br>​     short                   %hd<br>​     unsigned short  %hu<br>​     int %d<br>​     unsinged int       %u<br>​     long                     %ld<br>​     unsigned long   %lu<br>​     float                %f或者%g<br>​     double                %lf或者%lg<br>​%f,%lf和%g,%lg区别在于前者会保留**后面多余的0,**后者不会保留<br>​     <strong>回滚现象：</strong></p><p><strong>类型的整型数范围（正向超出范围）：</strong></p><p>char为例</p><p>-128~127</p><p>如果要求输出128，则整型数回滚为0；</p><p>类似的其他类型可类推</p><p>类型的数据溢出范围情况（负向超出范围）</p><p>unsigned char为例</p><p>对于unsigned char  0-255是范围</p><p>如果要求输出-1，则实际输出256（unsigned char的实际范围大小）-1  结果为255</p><p><strong>实际上也和正向超出范围类似，-1是负向超出，回滚到右边第一个，也就是255，上面是便捷的计算方法而已</strong></p><p>8.10.掌握sizeof关键字(而不是函数)<br>1)作用：计算一个变量或者一种数据类型所占用的内存空间大小,会给你一个大小结果<br>              单位是字节<br>2)格式：sizeof(变量名或者数据类型名),返回字节数<br>   例如：int a &#x3D; 250;<br>             printf(“sizeof(a)的大小是%d\n”, sizeof(a));<br>             printf(“sizeof(a)的大小是%d\n”, sizeof(int));<br>3)切记：sizeof关键字后面的小括号里对任何存储区内容的修改都是无效的</p><p>8.11.输入函数:scanf<br>1)已经掌握了输出函数：printf<br>2)输入函数scanf功能：能够让用户从键盘给程序输入数字并且保存到变量中(保存到内存中)<br>3)格式：scanf(格式串, 变量的地址列表);<br>   例如：<br>   int a, b;<br>   scanf(“%d%d”, &amp;a, &amp;b); &#x2F;&#x2F;从键盘上输入两个数分别给a和b,按照整型数的形式输入<br>                   &#x2F;&#x2F;键盘输入：100  200<br>   或者：<br>   scanf(“%d,%d”, &amp;a, &amp;b); &#x2F;&#x2F;键盘输入：100,200<br>4)注意<br>   1.为了使用此函数,必须添加头文件:#include &lt;stdio.h&gt;<br>   2.scanf函数双引号里面不要包含占位符以外的其他内容<br>   3.如果一次要输入多个数字,每个数字之间用空格键(帅的人)或者TAB键或者换行键隔开</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第一篇</title>
      <link href="/2022/08/28/%E7%AC%AC%E4%B8%80%E7%AF%87/"/>
      <url>/2022/08/28/%E7%AC%AC%E4%B8%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>开心</p><p>哈哈哈哈</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/08/28/hello-world/"/>
      <url>/2022/08/28/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
